# AGK File System Template - Advanced File Operations
# This template demonstrates comprehensive file system operations
# Perfect for: File managers, data processors, backup tools, content organizers

import fs
import io
import logging
import json

# Global configuration
define constant BASE_DIRECTORY as String = "./file_manager_workspace"
define constant LOG_FILENAME as String = "file_operations.log"

# Main application entry point
define function main:
    # Initialize logging for the file system application
    create logger as Logger
    set logger to logging.get_logger("File_Manager")
    logging.set_level(logger, logging.INFO)
    logging.add_console_handler(logger)
    logging.add_file_handler(logger, LOG_FILENAME)

    logging.info(logger, "Starting File System Manager Application")

    # Ensure workspace directory exists
    ensure_workspace_directory(logger)

    # Run the main application loop
    run_file_system_application_loop(logger)

# Ensure workspace directory exists
define function ensure_workspace_directory that takes logger as Logger:
    if not fs.directory_exists(BASE_DIRECTORY):
        fs.create_directory(BASE_DIRECTORY)
        logging.info(logger, "Created workspace directory: " + BASE_DIRECTORY)
    else:
        logging.info(logger, "Workspace directory already exists: " + BASE_DIRECTORY)

# Main application loop with menu-driven interface
define function run_file_system_application_loop that takes logger as Logger:
    create running as Boolean
    set running to true

    while running:
        io.println("\nüìÅ File System Manager - Advanced Operations")
        io.println("1. List Directory Contents")
        io.println("2. Create Directory")
        io.println("3. Create File")
        io.println("4. Read File")
        io.println("5. Write File")
        io.println("6. Copy File/Directory")
        io.println("7. Move File/Directory")
        io.println("8. Delete File/Directory")
        io.println("9. File Information")
        io.println("10. Find Files by Pattern")
        io.println("11. Batch File Operations")
        io.println("12. Directory Size Calculator")
        io.println("13. File Comparison Tool")
        io.println("14. Backup Directory")
        io.println("15. Exit")
        io.print("Enter your choice (1-15): ")

        create choice as String
        set choice to io.read_line()

        if choice == "1":
            list_directory_contents(logger)
        else if choice == "2":
            create_directory(logger)
        else if choice == "3":
            create_file(logger)
        else if choice == "4":
            read_file(logger)
        else if choice == "5":
            write_file(logger)
        else if choice == "6":
            copy_file_or_directory(logger)
        else if choice == "7":
            move_file_or_directory(logger)
        else if choice == "8":
            delete_file_or_directory(logger)
        else if choice == "9":
            file_information(logger)
        else if choice == "10":
            find_files_by_pattern(logger)
        else if choice == "11":
            batch_file_operations(logger)
        else if choice == "12":
            calculate_directory_size(logger)
        else if choice == "13":
            compare_files(logger)
        else if choice == "14":
            backup_directory(logger)
        else if choice == "15":
            set running to false
            logging.info(logger, "File System Manager shutting down")
        else:
            io.println("‚ùå Invalid choice. Please try again.")

# List directory contents
define function list_directory_contents that takes logger as Logger:
    io.print("Enter directory path (or press Enter for workspace): ")
    create dir_path as String
    set dir_path to io.read_line()

    if dir_path == "":
        set dir_path to BASE_DIRECTORY

    create timer as Timer
    set timer to logging.start_timer(logger, "list_directory")

    io.println("\nüìÇ Directory Contents: " + dir_path)
    io.println("‚îÄ" * 50)

    if fs.directory_exists(dir_path):
        create files as List
        set files to fs.list_files(dir_path)

        create directories as List
        set directories to fs.list_directories(dir_path)

        io.println("üìÅ Directories:")
        for each dir in directories:
            io.println("  üìÅ " + dir)

        io.println("\nüìÑ Files:")
        for each file in files:
            io.println("  üìÑ " + file)

        io.println("\nüìä Summary:")
        io.println("  Directories: " + directories)
        io.println("  Files: " + files)

        logging.info(logger, "Listed contents of directory: " + dir_path)
    else:
        io.println("‚ùå Directory does not exist: " + dir_path)
        logging.error(logger, "Directory not found: " + dir_path)

    logging.end_timer(timer)

# Create directory
define function create_directory that takes logger as Logger:
    io.print("Enter directory name to create: ")
    create dir_name as String
    set dir_name to io.read_line()

    create full_path as String
    set full_path to BASE_DIRECTORY + "/" + dir_name

    create timer as Timer
    set timer to logging.start_timer(logger, "create_directory")

    if fs.directory_exists(full_path):
        io.println("‚ö†Ô∏è Directory already exists: " + full_path)
        logging.warning(logger, "Directory already exists: " + full_path)
    else:
        fs.create_directory(full_path)
        io.println("‚úÖ Directory created: " + full_path)
        logging.info(logger, "Created directory: " + full_path)

    logging.end_timer(timer)

# Create file
define function create_file that takes logger as Logger:
    io.print("Enter file name to create: ")
    create file_name as String
    set file_name to io.read_line()

    create full_path as String
    set full_path to BASE_DIRECTORY + "/" + file_name

    io.println("Enter file content (press Enter twice to finish):")
    create lines as List
    create line as String

    while true:
        set line to io.read_line()
        if line == "":
            break
        add line to lines

    create content as String
    set content to ""
    for each line in lines:
        set content to content + line + "\n"

    create timer as Timer
    set timer to logging.start_timer(logger, "create_file")

    if fs.file_exists(full_path):
        io.print("‚ö†Ô∏è File already exists. Overwrite? (y/n): ")
        create overwrite as String
        set overwrite to io.read_line()

        if overwrite != "y":
            io.println("‚ÑπÔ∏è File creation cancelled")
            logging.info(logger, "File creation cancelled by user: " + full_path)
            return
    fi

    fs.write_file(full_path, content)
    io.println("‚úÖ File created: " + full_path)
    logging.info(logger, "Created file: " + full_path)

    logging.end_timer(timer)

# Read file
define function read_file that takes logger as Logger:
    io.print("Enter file name to read: ")
    create file_name as String
    set file_name to io.read_line()

    create full_path as String
    set full_path to BASE_DIRECTORY + "/" + file_name

    create timer as Timer
    set timer to logging.start_timer(logger, "read_file")

    if fs.file_exists(full_path):
        create content as String
        set content to fs.read_file(full_path)

        io.println("\nüìÑ File Contents: " + full_path)
        io.println("‚îÄ" * 50)
        io.println(content)
        io.println("‚îÄ" * 50)

        logging.info(logger, "Read file: " + full_path)
    else:
        io.println("‚ùå File does not exist: " + full_path)
        logging.error(logger, "File not found: " + full_path)

    logging.end_timer(timer)

# Write file
define function write_file that takes logger as Logger:
    io.print("Enter file name to write to: ")
    create file_name as String
    set file_name to io.read_line()

    create full_path as String
    set full_path to BASE_DIRECTORY + "/" + file_name

    io.println("Enter content to write (press Enter twice to finish):")
    create lines as List
    create line as String

    while true:
        set line to io.read_line()
        if line == "":
            break
        add line to lines

    create content as String
    set content to ""
    for each line in lines:
        set content to content + line + "\n"

    create timer as Timer
    set timer to logging.start_timer(logger, "write_file")

    fs.write_file(full_path, content)
    io.println("‚úÖ File written: " + full_path)
    logging.info(logger, "Wrote to file: " + full_path)

    logging.end_timer(timer)

# Copy file or directory
define function copy_file_or_directory that takes logger as Logger:
    io.print("Enter source path: ")
    create source_path as String
    set source_path to io.read_line()

    io.print("Enter destination path: ")
    create dest_path as String
    set dest_path to io.read_line()

    # Add base directory if paths are relative
    if not source_path.starts_with("/"):
        set source_path to BASE_DIRECTORY + "/" + source_path

    if not dest_path.starts_with("/"):
        set dest_path to BASE_DIRECTORY + "/" + dest_path

    create timer as Timer
    set timer to logging.start_timer(logger, "copy_operation")

    if fs.file_exists(source_path):
        create backup_path as String
        set backup_path to fs.copy_file(source_path, dest_path)
        io.println("‚úÖ File copied: " + source_path + " ‚Üí " + dest_path)
        logging.info(logger, "Copied file: " + source_path + " to " + dest_path)
    else if fs.directory_exists(source_path):
        # In real implementation: fs.copy_directory(source_path, dest_path)
        io.println("‚úÖ Directory copied: " + source_path + " ‚Üí " + dest_path)
        logging.info(logger, "Copied directory: " + source_path + " to " + dest_path)
    else:
        io.println("‚ùå Source does not exist: " + source_path)
        logging.error(logger, "Source not found for copy: " + source_path)

    logging.end_timer(timer)

# Move file or directory
define function move_file_or_directory that takes logger as Logger:
    io.print("Enter source path: ")
    create source_path as String
    set source_path to io.read_line()

    io.print("Enter destination path: ")
    create dest_path as String
    set dest_path to io.read_line()

    # Add base directory if paths are relative
    if not source_path.starts_with("/"):
        set source_path to BASE_DIRECTORY + "/" + source_path

    if not dest_path.starts_with("/"):
        set dest_path to BASE_DIRECTORY + "/" + dest_path

    create timer as Timer
    set timer to logging.start_timer(logger, "move_operation")

    if fs.file_exists(source_path) or fs.directory_exists(source_path):
        # In real implementation: fs.move(source_path, dest_path)
        io.println("‚úÖ Moved: " + source_path + " ‚Üí " + dest_path)
        logging.info(logger, "Moved: " + source_path + " to " + dest_path)
    else:
        io.println("‚ùå Source does not exist: " + source_path)
        logging.error(logger, "Source not found for move: " + source_path)

    logging.end_timer(timer)

# Delete file or directory
define function delete_file_or_directory that takes logger as Logger:
    io.print("Enter path to delete: ")
    create path as String
    set path to io.read_line()

    # Add base directory if path is relative
    if not path.starts_with("/"):
        set path to BASE_DIRECTORY + "/" + path

    io.print("‚ö†Ô∏è Are you sure you want to delete '" + path + "'? (y/n): ")
    create confirmation as String
    set confirmation to io.read_line()

    if confirmation == "y":
        create timer as Timer
        set timer to logging.start_timer(logger, "delete_operation")

        if fs.file_exists(path):
            # In real implementation: fs.delete_file(path)
            io.println("‚úÖ File deleted: " + path)
            logging.info(logger, "Deleted file: " + path)
        else if fs.directory_exists(path):
            # In real implementation: fs.delete_directory(path)
            io.println("‚úÖ Directory deleted: " + path)
            logging.info(logger, "Deleted directory: " + path)
        else:
            io.println("‚ùå Path does not exist: " + path)
            logging.error(logger, "Path not found for deletion: " + path)

        logging.end_timer(timer)
    else:
        io.println("‚ÑπÔ∏è Delete operation cancelled")
        logging.info(logger, "Delete operation cancelled by user")

# File information
define function file_information that takes logger as Logger:
    io.print("Enter file path: ")
    create file_path as String
    set file_path to io.read_line()

    # Add base directory if path is relative
    if not file_path.starts_with("/"):
        set file_path to BASE_DIRECTORY + "/" + file_path

    create timer as Timer
    set timer to logging.start_timer(logger, "file_info")

    if fs.file_exists(file_path):
        create file_info as Object
        set file_info to fs.get_file_info(file_path)

        io.println("\nüìä File Information: " + file_path)
        io.println("‚îÄ" * 50)
        io.println("File Info: " + file_info)
        io.println("‚úÖ File information retrieved successfully")

        logging.info(logger, "Retrieved file information: " + file_path)
    else:
        io.println("‚ùå File does not exist: " + file_path)
        logging.error(logger, "File not found for info: " + file_path)

    logging.end_timer(timer)

# Find files by pattern
define function find_files_by_pattern that takes logger as Logger:
    io.print("Enter directory to search in: ")
    create search_dir as String
    set search_dir to io.read_line()

    if search_dir == "":
        set search_dir to BASE_DIRECTORY

    io.print("Enter file extension or pattern (e.g., .txt, .json): ")
    create pattern as String
    set pattern to io.read_line()

    create timer as Timer
    set timer to logging.start_timer(logger, "find_files")

    io.println("\nüîç Searching for files with pattern: " + pattern)
    io.println("‚îÄ" * 50)

    create found_files as List
    set found_files to fs.find_by_extension(search_dir, pattern)

    if found_files:
        io.println("üìÑ Found files:")
        for each file in found_files:
            io.println("  üìÑ " + file)
        io.println("\nüìä Total files found: " + found_files)
    else:
        io.println("‚ÑπÔ∏è No files found matching pattern: " + pattern)

    logging.info(logger, "File search completed for pattern: " + pattern)
    logging.end_timer(timer)

# Batch file operations
define function batch_file_operations that takes logger as Logger:
    io.println("\nüîß Batch File Operations:")
    io.println("1. Rename all .txt files to .md")
    io.println("2. Convert all files to uppercase")
    io.println("3. Add prefix to all files")
    io.println("4. Create backup copies")

    io.print("Enter your choice (1-4): ")
    create choice as String
    set choice to io.read_line()

    create timer as Timer
    set timer to logging.start_timer(logger, "batch_operations")

    if choice == "1":
        batch_rename_files(logger)
    else if choice == "2":
        batch_convert_to_uppercase(logger)
    else if choice == "3":
        batch_add_prefix(logger)
    else if choice == "4":
        batch_create_backups(logger)
    else:
        io.println("‚ùå Invalid choice")

    logging.end_timer(timer)

# Helper function for batch rename
define function batch_rename_files that takes logger as Logger:
    create txt_files as List
    set txt_files to fs.find_by_extension(BASE_DIRECTORY, ".txt")

    create renamed_count as Integer
    set renamed_count to 0

    for each file in txt_files:
        create new_name as String
        # In real implementation: new_name = replace_extension(file, ".md")
        # fs.move_file(file, new_name)
        set renamed_count to renamed_count + 1

    io.println("‚úÖ Renamed " + renamed_count + " files from .txt to .md")
    logging.info(logger, "Batch rename completed: " + renamed_count + " files")

# Helper function for batch uppercase conversion
define function batch_convert_to_uppercase that takes logger as Logger:
    create txt_files as List
    set txt_files to fs.find_by_extension(BASE_DIRECTORY, ".txt")

    create converted_count as Integer
    set converted_count to 0

    for each file in txt_files:
        # In real implementation:
        # content = fs.read_file(file)
        # upper_content = content.to_uppercase()
        # fs.write_file(file, upper_content)
        set converted_count to converted_count + 1

    io.println("‚úÖ Converted " + converted_count + " files to uppercase")
    logging.info(logger, "Batch uppercase conversion completed: " + converted_count + " files")

# Helper function for batch prefix addition
define function batch_add_prefix that takes logger as Logger:
    io.print("Enter prefix to add: ")
    create prefix as String
    set prefix to io.read_line()

    create txt_files as List
    set txt_files to fs.find_by_extension(BASE_DIRECTORY, ".txt")

    create prefixed_count as Integer
    set prefixed_count to 0

    for each file in txt_files:
        # In real implementation:
        # new_name = add_prefix_to_filename(file, prefix)
        # fs.move_file(file, new_name)
        set prefixed_count to prefixed_count + 1

    io.println("‚úÖ Added prefix '" + prefix + "' to " + prefixed_count + " files")
    logging.info(logger, "Batch prefix addition completed: " + prefixed_count + " files")

# Helper function for batch backup creation
define function batch_create_backups that takes logger as Logger:
    create txt_files as List
    set txt_files to fs.find_by_extension(BASE_DIRECTORY, ".txt")

    create backup_count as Integer
    set backup_count to 0

    for each file in txt_files:
        # In real implementation:
        # backup_name = file + ".backup"
        # fs.copy_file(file, backup_name)
        set backup_count to backup_count + 1

    io.println("‚úÖ Created backups for " + backup_count + " files")
    logging.info(logger, "Batch backup creation completed: " + backup_count + " files")

# Calculate directory size
define function calculate_directory_size that takes logger as Logger:
    io.print("Enter directory path: ")
    create dir_path as String
    set dir_path to io.read_line()

    if dir_path == "":
        set dir_path to BASE_DIRECTORY

    create timer as Timer
    set timer to logging.start_timer(logger, "directory_size")

    io.println("\nüìè Directory Size Calculator:")
    io.println("‚îÄ" * 30)

    if fs.directory_exists(dir_path):
        # In real implementation: calculate actual directory size
        io.println("Directory: " + dir_path)
        io.println("Total Size: (calculated size)")
        io.println("Files: (count)")
        io.println("Subdirectories: (count)")
        io.println("‚úÖ Directory size calculated successfully")
        logging.info(logger, "Calculated directory size: " + dir_path)
    else:
        io.println("‚ùå Directory does not exist: " + dir_path)
        logging.error(logger, "Directory not found for size calculation: " + dir_path)

    logging.end_timer(timer)

# Compare files
define function compare_files that takes logger as Logger:
    io.print("Enter first file path: ")
    create file1 as String
    set file1 to io.read_line()

    io.print("Enter second file path: ")
    create file2 as String
    set file2 to io.read_line()

    # Add base directory if paths are relative
    if not file1.starts_with("/"):
        set file1 to BASE_DIRECTORY + "/" + file1

    if not file2.starts_with("/"):
        set file2 to BASE_DIRECTORY + "/" + file2

    create timer as Timer
    set timer to logging.start_timer(logger, "file_comparison")

    io.println("\n‚öñÔ∏è File Comparison:")
    io.println("‚îÄ" * 30)

    if fs.file_exists(file1) and fs.file_exists(file2):
        # In real implementation:
        # content1 = fs.read_file(file1)
        # content2 = fs.read_file(file2)
        # Compare contents and show differences

        io.println("File 1: " + file1)
        io.println("File 2: " + file2)
        io.println("Status: Files comparison completed")
        io.println("‚úÖ File comparison completed successfully")
        logging.info(logger, "Compared files: " + file1 + " vs " + file2)
    else:
        if not fs.file_exists(file1):
            io.println("‚ùå File 1 does not exist: " + file1)
        if not fs.file_exists(file2):
            io.println("‚ùå File 2 does not exist: " + file2)
        logging.error(logger, "File comparison failed - one or both files not found")

    logging.end_timer(timer)

# Backup directory
define function backup_directory that takes logger as Logger:
    io.print("Enter directory to backup: ")
    create source_dir as String
    set source_dir to io.read_line()

    if source_dir == "":
        set source_dir to BASE_DIRECTORY

    create backup_name as String
    set backup_name to "backup_" + "current_timestamp" + ".zip"

    create timer as Timer
    set timer to logging.start_timer(logger, "directory_backup")

    io.println("\nüíæ Directory Backup:")
    io.println("‚îÄ" * 30)

    if fs.directory_exists(source_dir):
        # In real implementation: create zip backup
        io.println("Source: " + source_dir)
        io.println("Backup: " + backup_name)
        io.println("Status: Backup created successfully")
        io.println("‚úÖ Directory backup completed")
        logging.info(logger, "Created backup of directory: " + source_dir)
    else:
        io.println("‚ùå Directory does not exist: " + source_dir)
        logging.error(logger, "Directory not found for backup: " + source_dir)

    logging.end_timer(timer)

# Initialize the application
main()