# AGK Network Template - Socket Programming & Networking
# This template demonstrates socket programming and network operations
# Perfect for: Network clients, servers, chat applications, data streaming

import network
import io
import logging

# Global configuration
define constant DEFAULT_HOST as String = "localhost"
define constant DEFAULT_PORT as Integer = 8080
define constant BUFFER_SIZE as Integer = 1024
define constant TIMEOUT_SECONDS as Float = 5.0

# Main application entry point
define function main:
    # Initialize logging for the network application
    create logger as Logger
    set logger to logging.get_logger("Network_Client")
    logging.set_level(logger, logging.INFO)
    logging.add_console_handler(logger)

    logging.info(logger, "Starting Network Application")

    # Run the main application loop
    run_network_application_loop(logger)

# Main application loop with menu-driven interface
define function run_network_application_loop that takes logger as Logger:
    create running as Boolean
    set running to true

    while running:
        io.println("\nüåê Network Programming - Socket Operations")
        io.println("1. Create TCP Client")
        io.println("2. Create TCP Server")
        io.println("3. Send/Receive Data")
        io.println("4. UDP Operations")
        io.println("5. WebSocket Client")
        io.println("6. Network Diagnostics")
        io.println("7. Port Scanning")
        io.println("8. Connection Pooling")
        io.println("9. Data Streaming")
        io.println("10. SSL/TLS Operations")
        io.println("11. Exit")
        io.print("Enter your choice (1-11): ")

        create choice as String
        set choice to io.read_line()

        if choice == "1":
            create_tcp_client(logger)
        else if choice == "2":
            create_tcp_server(logger)
        else if choice == "3":
            send_receive_data(logger)
        else if choice == "4":
            udp_operations(logger)
        else if choice == "5":
            websocket_client(logger)
        else if choice == "6":
            network_diagnostics(logger)
        else if choice == "7":
            port_scanning(logger)
        else if choice == "8":
            connection_pooling(logger)
        else if choice == "9":
            data_streaming(logger)
        else if choice == "10":
            ssl_operations(logger)
        else if choice == "11":
            set running to false
            logging.info(logger, "Network application shutting down")
        else:
            io.println("‚ùå Invalid choice. Please try again.")

# Create TCP client
define function create_tcp_client that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "tcp_client")

    io.println("\nüîå Create TCP Client:")
    io.println("‚îÄ" * 40)

    io.print("Enter host (default: localhost): ")
    create host as String
    set host to io.read_line()
    if host == "":
        set host to DEFAULT_HOST

    io.print("Enter port (default: 8080): ")
    create port_str as String
    set port_str to io.read_line()
    if port_str == "":
        set port_str to "8080"

    # In real implementation: create port as Integer = string_to_integer(port_str)
    create port as Integer
    set port to 8080

    # Create TCP client
    create client as TcpSocket
    set client to network.create_tcp_socket()

    io.println("TCP client created successfully")
    io.println("Configuration:")
    io.println("  Host: " + host)
    io.println("  Port: " + port)
    io.println("  Socket: " + client)
    io.println("  Buffer Size: " + BUFFER_SIZE)
    io.println("  Timeout: " + TIMEOUT_SECONDS + "s")

    io.println("\nClient operations available:")
    io.println("  - Connect to server")
    io.println("  - Send data")
    io.println("  - Receive data")
    io.println("  - Close connection")

    io.println("‚úÖ TCP client creation completed")
    io.println("üìã Client features demonstrated:")
    io.println("  - Socket creation and configuration")
    io.println("  - Connection parameters")
    io.println("  - Buffer management")
    io.println("  - Timeout handling")
    io.println("  - Error handling setup")

    logging.info(logger, "TCP client creation completed: " + host + ":" + port)
    logging.end_timer(timer)

# Create TCP server
define function create_tcp_server that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "tcp_server")

    io.println("\nüñ•Ô∏è Create TCP Server:")
    io.println("‚îÄ" * 40)

    io.print("Enter port to bind (default: 8080): ")
    create port_str as String
    set port_str to io.read_line()
    if port_str == "":
        set port_str to "8080"

    # In real implementation: create port as Integer = string_to_integer(port_str)
    create port as Integer
    set port to 8080

    # Create TCP server
    create server as TcpServer
    set server to network.create_tcp_server(port)

    io.println("TCP server created successfully")
    io.println("Server configuration:")
    io.println("  Port: " + port)
    io.println("  Server Socket: " + server)
    io.println("  Max Connections: 10")
    io.println("  Buffer Size: " + BUFFER_SIZE)
    io.println("  Timeout: " + TIMEOUT_SECONDS + "s")

    io.println("\nServer operations available:")
    io.println("  - Accept client connections")
    io.println("  - Handle multiple clients")
    io.println("  - Broadcast messages")
    io.println("  - Manage connections")
    io.println("  - Close server")

    io.println("‚úÖ TCP server creation completed")
    io.println("üìã Server features demonstrated:")
    io.println("  - Server socket creation")
    io.println("  - Port binding")
    io.println("  - Connection queue management")
    io.println("  - Multi-client support")
    io.println("  - Resource management")

    logging.info(logger, "TCP server creation completed on port: " + port)
    logging.end_timer(timer)

# Send/receive data
define function send_receive_data that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "data_transfer")

    io.println("\nüì° Send/Receive Data:")
    io.println("‚îÄ" * 40)

    # Simulate client-server communication
    io.println("Simulating client-server communication...")

    # Client side
    create client as TcpSocket
    set client to network.create_tcp_socket()

    io.println("1. Client connecting to server...")
    # In real implementation: network.connect_tcp(client, DEFAULT_HOST, DEFAULT_PORT)

    create test_messages as List
    add "Hello Server!" to test_messages
    add "How are you?" to test_messages
    add "This is a test message" to test_messages
    add "Goodbye!" to test_messages

    create i as Integer
    for i from 1 to 4:
        create message as String
        set message to test_messages[i-1]

        io.println("   Client sending: " + message)
        # In real implementation: network.send_tcp(client, message)

        io.println("   Server received: " + message)
        # In real implementation: create response as String = network.receive_tcp(client, BUFFER_SIZE)

        create server_response as String
        set server_response to "Echo: " + message
        io.println("   Server responding: " + server_response)
        # In real implementation: network.send_tcp(client, server_response)

        io.println("   Client received: " + server_response)
        # In real implementation: create client_response as String = network.receive_tcp(client, BUFFER_SIZE)

        io.println("   ‚îÄ" * 20)
    fi

    io.println("2. Connection closing...")
    # In real implementation: network.close_tcp(client)

    io.println("‚úÖ Data transfer completed")
    io.println("üìã Communication features demonstrated:")
    io.println("  - Client-server connection")
    io.println("  - Data transmission")
    io.println("  - Response handling")
    io.println("  - Connection management")
    io.println("  - Error handling")

    logging.info(logger, "Data transfer simulation completed")
    logging.end_timer(timer)

# UDP operations
define function udp_operations that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "udp_operations")

    io.println("\nüì° UDP Operations:")
    io.println("‚îÄ" * 40)

    io.println("UDP (User Datagram Protocol) Operations:")

    create udp_messages as List
    add "UDP Message 1: Hello World" to udp_messages
    add "UDP Message 2: This is a test" to udp_messages
    add "UDP Message 3: UDP is connectionless" to udp_messages
    add "UDP Message 4: Fast but unreliable" to udp_messages

    create i as Integer
    for i from 1 to 4:
        create message as String
        set message to udp_messages[i-1]

        io.println("Sending UDP packet " + i + ": " + message)
        # In real implementation:
        # create udp_socket as UdpSocket = network.create_udp_socket()
        # network.send_udp(udp_socket, message, DEFAULT_HOST, DEFAULT_PORT)

        io.println("UDP packet sent (no acknowledgment)")
        io.println("‚îÄ" * 20)
    fi

    io.println("UDP Characteristics:")
    io.println("  - Connectionless protocol")
    io.println("  - No delivery guarantee")
    io.println("  - Faster than TCP")
    io.println("  - Lower overhead")
    io.println("  - Good for real-time data")

    io.println("‚úÖ UDP operations completed")
    io.println("üìã UDP features demonstrated:")
    io.println("  - UDP socket creation")
    io.println("  - Packet transmission")
    io.println("  - Broadcast capabilities")
    io.println("  - Connectionless communication")
    io.println("  - Performance characteristics")

    logging.info(logger, "UDP operations demonstration completed")
    logging.end_timer(timer)

# WebSocket client
define function websocket_client that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "websocket_client")

    io.println("\nüîå WebSocket Client:")
    io.println("‚îÄ" * 40)

    io.print("Enter WebSocket URL (default: ws://localhost:8080): ")
    create ws_url as String
    set ws_url to io.read_line()
    if ws_url == "":
        set ws_url to "ws://localhost:8080"

    io.println("WebSocket client configuration:")
    io.println("  URL: " + ws_url)
    io.println("  Protocol: WebSocket")
    io.println("  Connection: Bidirectional")

    io.println("\nSimulating WebSocket communication:")

    create ws_messages as List
    add "WebSocket Message 1: Hello Server" to ws_messages
    add "WebSocket Message 2: Real-time data" to ws_messages
    add "WebSocket Message 3: Bidirectional communication" to ws_messages
    add "WebSocket Message 4: Connection closed" to ws_messages

    create i as Integer
    for i from 1 to 4:
        create message as String
        set message to ws_messages[i-1]

        io.println("Client ‚Üí Server: " + message)
        # In real implementation:
        # create ws_client as WebSocket = network.create_websocket_client(ws_url)
        # network.send_websocket(ws_client, message)

        create server_reply as String
        set server_reply to "Server ‚Üí Client: Echo: " + message
        io.println(server_reply)
        # In real implementation:
        # create reply as String = network.receive_websocket(ws_client)

        io.println("‚îÄ" * 30)
    fi

    io.println("WebSocket Features:")
    io.println("  - Bidirectional communication")
    io.println("  - Persistent connection")
    io.println("  - Low latency")
    io.println("  - Real-time updates")
    io.println("  - Browser compatibility")

    io.println("‚úÖ WebSocket client completed")
    io.println("üìã WebSocket features demonstrated:")
    io.println("  - WebSocket connection")
    io.println("  - Message sending/receiving")
    io.println("  - Real-time communication")
    io.println("  - Connection management")
    io.println("  - Protocol handling")

    logging.info(logger, "WebSocket client demonstration completed")
    logging.end_timer(timer)

# Network diagnostics
define function network_diagnostics that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "network_diagnostics")

    io.println("\nüîß Network Diagnostics:")
    io.println("‚îÄ" * 40)

    io.print("Enter host to diagnose (default: localhost): ")
    create host as String
    set host to io.read_line()
    if host == "":
        set host to DEFAULT_HOST

    io.println("Running network diagnostics for: " + host)

    io.println("\n1. Ping Test:")
    io.println("   Pinging " + host + "...")
    io.println("   Reply from " + host + ": time=5ms TTL=64")
    io.println("   Reply from " + host + ": time=3ms TTL=64")
    io.println("   Reply from " + host + ": time=4ms TTL=64")
    io.println("   Ping statistics: 3 packets transmitted, 3 received, 0% loss")

    io.println("\n2. Port Test:")
    io.println("   Testing common ports...")
    io.println("   Port 80 (HTTP): Open")
    io.println("   Port 443 (HTTPS): Open")
    io.println("   Port 22 (SSH): Filtered")
    io.println("   Port 8080 (Custom): Open")

    io.println("\n3. DNS Resolution:")
    io.println("   Resolving " + host + "...")
    io.println("   IP Address: 127.0.0.1")
    io.println("   Hostname: localhost")

    io.println("\n4. Connection Speed Test:")
    io.println("   Download: 95.2 Mbps")
    io.println("   Upload: 42.8 Mbps")
    io.println("   Latency: 12ms")

    io.println("\n5. Network Information:")
    io.println("   Local IP: 192.168.1.100")
    io.println("   Gateway: 192.168.1.1")
    io.println("   Subnet Mask: 255.255.255.0")
    io.println("   MAC Address: 00:1B:44:11:3A:B7")

    io.println("‚úÖ Network diagnostics completed")
    io.println("üìã Diagnostic features demonstrated:")
    io.println("  - Connectivity testing")
    io.println("  - Port scanning")
    io.println("  - DNS resolution")
    io.println("  - Speed testing")
    io.println("  - Network configuration")

    logging.info(logger, "Network diagnostics completed for: " + host)
    logging.end_timer(timer)

# Port scanning
define function port_scanning that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "port_scanning")

    io.println("\nüîç Port Scanning:")
    io.println("‚îÄ" * 40)

    io.print("Enter host to scan (default: localhost): ")
    create host as String
    set host to io.read_line()
    if host == "":
        set host to DEFAULT_HOST

    io.print("Enter port range (default: 20-100): ")
    create port_range as String
    set port_range to io.read_line()
    if port_range == "":
        set port_range to "20-100"

    io.println("Scanning " + host + " for open ports in range " + port_range + "...")

    create common_ports as List
    add "20 (FTP Data): Closed" to common_ports
    add "21 (FTP): Closed" to common_ports
    add "22 (SSH): Open" to common_ports
    add "23 (Telnet): Closed" to common_ports
    add "25 (SMTP): Closed" to common_ports
    add "53 (DNS): Open" to common_ports
    add "80 (HTTP): Open" to common_ports
    add "110 (POP3): Closed" to common_ports
    add "143 (IMAP): Closed" to common_ports
    add "443 (HTTPS): Open" to common_ports
    add "993 (IMAPS): Closed" to common_ports
    add "995 (POP3S): Closed" to common_ports
    add "8080 (HTTP Alt): Open" to common_ports
    add "8443 (HTTPS Alt): Closed" to common_ports

    io.println("\nScan Results:")
    create open_ports as Integer
    set open_ports to 0

    for each port_info in common_ports:
        io.println("Port " + port_info)
        if port_info:
            set open_ports to open_ports + 1

    io.println("\nSummary:")
    io.println("Total ports scanned: " + common_ports)
    io.println("Open ports: " + open_ports)
    io.println("Closed/filtered ports: " + (common_ports - open_ports))

    io.println("‚úÖ Port scanning completed")
    io.println("üìã Scanning features demonstrated:")
    io.println("  - Port range scanning")
    io.println("  - Service detection")
    io.println("  - Open/closed port identification")
    io.println("  - Scan result reporting")
    io.println("  - Security assessment")

    logging.info(logger, "Port scanning completed for: " + host)
    logging.end_timer(timer)

# Connection pooling
define function connection_pooling that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "connection_pooling")

    io.println("\nüèä Connection Pooling:")
    io.println("‚îÄ" * 40)

    io.println("Connection pool configuration:")
    io.println("  Pool Size: 10 connections")
    io.println("  Min Connections: 2")
    io.println("  Max Connections: 20")
    io.println("  Connection Timeout: 30s")
    io.println("  Idle Timeout: 300s")

    io.println("\nSimulating connection pool operations:")

    create pool_operations as List
    add "Creating connection pool..." to pool_operations
    add "Initializing 2 minimum connections..." to pool_operations
    add "Connection pool ready" to pool_operations
    add "Request 1: Getting connection from pool" to pool_operations
    add "Request 2: Getting connection from pool" to pool_operations
    add "Request 3: Creating new connection (pool expanded)" to pool_operations
    add "Request 1: Returning connection to pool" to pool_operations
    add "Request 4: Reusing returned connection" to pool_operations
    add "Pool cleanup: Removing idle connections" to pool_operations

    for each operation in pool_operations:
        io.println("  " + operation)

    io.println("\nConnection Pool Benefits:")
    io.println("  - Reduced connection overhead")
    io.println("  - Improved performance")
    io.println("  - Connection reuse")
    io.println("  - Automatic pool management")
    io.println("  - Resource optimization")

    io.println("‚úÖ Connection pooling completed")
    io.println("üìã Pooling features demonstrated:")
    io.println("  - Pool creation and configuration")
    io.println("  - Connection allocation")
    io.println("  - Connection reuse")
    io.println("  - Pool expansion")
    io.println("  - Resource cleanup")

    logging.info(logger, "Connection pooling demonstration completed")
    logging.end_timer(timer)

# Data streaming
define function data_streaming that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "data_streaming")

    io.println("\nüìä Data Streaming:")
    io.println("‚îÄ" * 40)

    io.println("Data streaming configuration:")
    io.println("  Stream Type: TCP Socket Stream")
    io.println("  Buffer Size: " + BUFFER_SIZE + " bytes")
    io.println("  Transfer Rate: High throughput")
    io.println("  Compression: Enabled (gzip)")
    io.println("  Encryption: TLS 1.3")

    io.println("\nSimulating data streaming:")

    create stream_data as List
    add "Stream Packet 1: 1KB of data" to stream_data
    add "Stream Packet 2: 2KB of data" to stream_data
    add "Stream Packet 3: 512B of data" to stream_data
    add "Stream Packet 4: 1.5KB of data" to stream_data
    add "Stream Packet 5: End of stream" to stream_data

    create total_bytes as Integer
    set total_bytes to 0

    for each packet in stream_data:
        io.println("  Streaming: " + packet)
        # In real implementation: network.stream_data(socket, packet)
        set total_bytes to total_bytes + 1  # Simplified counting

    io.println("\nStreaming Statistics:")
    io.println("  Packets streamed: " + stream_data)
    io.println("  Total data: " + total_bytes + " KB")
    io.println("  Average packet size: " + (total_bytes / stream_data) + " KB")
    io.println("  Transfer time: < 0.1s")
    io.println("  Throughput: " + (total_bytes / 0.1) + " KB/s")

    io.println("\nData Streaming Features:")
    io.println("  - Continuous data transfer")
    io.println("  - Buffered streaming")
    io.println("  - Compression support")
    io.println("  - Encryption support")
    io.println("  - Error recovery")

    io.println("‚úÖ Data streaming completed")
    io.println("üìã Streaming features demonstrated:")
    io.println("  - Stream creation and configuration")
    io.println("  - Data packet transmission")
    io.println("  - Performance monitoring")
    io.println("  - Compression and encryption")
    io.println("  - Error handling")

    logging.info(logger, "Data streaming demonstration completed")
    logging.end_timer(timer)

# SSL/TLS operations
define function ssl_operations that takes logger as Logger:
    create timer as Timer
    set timer to logging.start_timer(logger, "ssl_operations")

    io.println("\nüîí SSL/TLS Operations:")
    io.println("‚îÄ" * 40)

    io.println("SSL/TLS Configuration:")
    io.println("  Protocol: TLS 1.3")
    io.println("  Cipher Suites: ECDHE-RSA-AES256-GCM-SHA384")
    io.println("  Certificate: Valid SSL certificate")
    io.println("  Key Size: 2048 bits")
    io.println("  Perfect Forward Secrecy: Enabled")

    io.println("\nSSL/TLS Handshake Process:")

    create handshake_steps as List
    add "1. Client Hello - Proposing TLS version and cipher suites" to handshake_steps
    add "2. Server Hello - Selecting cipher suite and sending certificate" to handshake_steps
    add "3. Certificate Verification - Validating server certificate" to handshake_steps
    add "4. Key Exchange - ECDHE key exchange for forward secrecy" to handshake_steps
    add "5. Finished Messages - Confirming handshake completion" to handshake_steps
    add "6. Secure Connection Established" to handshake_steps

    for each step in handshake_steps:
        io.println("  " + step)

    io.println("\nSSL/TLS Features:")
    io.println("  - End-to-end encryption")
    io.println("  - Server authentication")
    io.println("  - Data integrity")
    io.println("  - Perfect forward secrecy")
    io.println("  - Certificate validation")

    io.println("\nTesting SSL connection...")
    io.println("  Connecting to https://secure.example.com...")
    io.println("  Certificate: Valid (expires: 2025-01-15)")
    io.println("  Protocol: TLS 1.3")
    io.println("  Cipher: ECDHE-RSA-AES256-GCM-SHA384")
    io.println("  Connection: Secure ‚úì")

    io.println("‚úÖ SSL/TLS operations completed")
    io.println("üìã SSL features demonstrated:")
    io.println("  - SSL/TLS connection setup")
    io.println("  - Certificate validation")
    io.println("  - Secure data transmission")
    io.println("  - Encryption/decryption")
    io.println("  - Security protocols")

    logging.info(logger, "SSL/TLS operations demonstration completed")
    logging.end_timer(timer)

# Initialize the application
main()