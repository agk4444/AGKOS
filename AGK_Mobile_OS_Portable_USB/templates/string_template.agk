# AGK String Template - Text Processing & String Manipulation
# This template demonstrates comprehensive string operations including
# text processing, pattern matching, formatting, encoding, and parsing
# Perfect for: Text processing applications, data validation, parsers, formatters

import string
import io
import logging
import json
import regex

# Global configuration
define constant TEST_TEXT as String = "Hello, World! Welcome to AGK string processing."
define constant SAMPLE_SENTENCE as String = "The quick brown fox jumps over the lazy dog."
define constant SAMPLE_HTML as String = "<div class='container'><h1>Title</h1><p>Content here</p></div>"
define constant SAMPLE_JSON as String = '{"name": "John", "age": 30, "city": "New York"}'

# Main application entry point
define function main:
    # Initialize logging for the string application
    create logger as Logger
    set logger to logging.get_logger("String_App")
    logging.set_level(logger, logging.INFO)
    logging.add_console_handler(logger)

    logging.info(logger, "Starting AGK String Processing Application")

    # Run the main application loop
    run_string_application_loop(logger)

# Main application loop with menu-driven interface
define function run_string_application_loop that takes logger as Logger:
    create running as Boolean
    set running to true

    while running:
        io.println("\n📝 AGK String Processing Environment")
        io.println("1. Basic String Operations")
        io.println("2. String Analysis & Statistics")
        io.println("3. Search & Pattern Matching")
        io.println("4. String Transformation")
        io.println("5. String Formatting")
        io.println("6. Text Parsing & Extraction")
        io.println("7. Encoding & Decoding")
        io.println("8. String Validation")
        io.println("9. Text Processing Utilities")
        io.println("10. Regular Expressions")
        io.println("11. Exit")
        io.print("Enter your choice (1-11): ")

        create choice as String
        set choice to io.read_line()

        if choice == "1":
            basic_string_demo(logger)
        else if choice == "2":
            string_analysis_demo(logger)
        else if choice == "3":
            search_demo(logger)
        else if choice == "4":
            transformation_demo(logger)
        else if choice == "5":
            formatting_demo(logger)
        else if choice == "6":
            parsing_demo(logger)
        else if choice == "7":
            encoding_demo(logger)
        else if choice == "8":
            validation_demo(logger)
        else if choice == "9":
            text_processing_demo(logger)
        else if choice == "10":
            regex_demo(logger)
        else if choice == "11":
            set running to false
            logging.info(logger, "String application shutting down")
        else:
            io.println("❌ Invalid choice. Please try again.")

# Basic string operations demonstration
define function basic_string_demo that takes logger as Logger:
    io.println("\n🔤 Basic String Operations")

    io.print("Enter a string: ")
    create input_str as String
    set input_str to io.read_line()

    if input_str == "":
        set input_str to TEST_TEXT

    io.println("String: '" + input_str + "'")
    io.println("─" * 50)
    io.println("Length: " + string(string.length(input_str)) + " characters")
    io.println("Uppercase: " + string.uppercase(input_str))
    io.println("Lowercase: " + string.lowercase(input_str))
    io.println("First character: '" + substring(input_str, 0, 1) + "'")
    io.println("Last character: '" + substring(input_str, string.length(input_str) - 1, 1) + "'")

    if string.length(input_str) >= 5:
        io.println("First 5 characters: '" + substring(input_str, 0, 5) + "'")
        io.println("Last 5 characters: '" + substring(input_str, string.length(input_str) - 5, 5) + "'")

    logging.info(logger, "Basic string operations completed")

# String analysis and statistics
define function string_analysis_demo that takes logger as Logger:
    io.println("\n📊 String Analysis & Statistics")

    io.print("Enter text to analyze: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to SAMPLE_SENTENCE

    io.println("Analyzing: '" + text + "'")
    io.println("─" * 60)

    create char_count as Integer
    set char_count to string.length(text)
    io.println("Character count: " + string(char_count))

    create word_list as List
    set word_list to string.split(text, " ")
    create word_count as Integer
    set word_count to length(word_list)
    io.println("Word count: " + string(word_count))

    create sentence_count as Integer
    set sentence_count to count_occurrences(text, ".") + count_occurrences(text, "!") + count_occurrences(text, "?")
    io.println("Sentence count: " + string(sentence_count))

    create avg_word_length as Float
    set avg_word_length to calculate_average_word_length(word_list)
    io.println("Average word length: " + string(avg_word_length) + " characters")

    io.println("\nCharacter frequency:")
    create char_freq as Object
    set char_freq to analyze_character_frequency(text)

    create chars as List
    set chars to get_object_keys(char_freq)
    create i as Integer
    set i to 0
    while i < length(chars):
        create char as String
        set char to chars[i]
        create count as Integer
        set count to char_freq[char]
        io.println("  '" + char + "': " + string(count) + " times")
        set i to i + 1

    logging.info(logger, "String analysis completed")

# Search and pattern matching
define function search_demo that takes logger as Logger:
    io.println("\n🔍 Search & Pattern Matching")

    io.print("Enter text to search in: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to SAMPLE_SENTENCE

    io.print("Enter pattern to search for: ")
    create pattern as String
    set pattern to io.read_line()

    if pattern == "":
        set pattern to "fox"

    io.println("Searching for '" + pattern + "' in:")
    io.println("'" + text + "'")
    io.println("─" * 50)

    # Basic search operations
    create contains_pattern as Boolean
    set contains_pattern to string.contains(text, pattern)
    io.println("Contains pattern: " + (contains_pattern ? "Yes" : "No"))

    create starts_with_pattern as Boolean
    set starts_with_pattern to string.starts_with(text, pattern)
    io.println("Starts with pattern: " + (starts_with_pattern ? "Yes" : "No"))

    create ends_with_pattern as Boolean
    set ends_with_pattern to string.ends_with(text, pattern)
    io.println("Ends with pattern: " + (ends_with_pattern ? "Yes" : "No"))

    # Find all occurrences
    create occurrences as List
    set occurrences to find_all_occurrences(text, pattern)

    if length(occurrences) > 0:
        io.println("Found " + string(length(occurrences)) + " occurrence(s) at positions:")
        create i as Integer
        set i to 0
        while i < length(occurrences):
            io.println("  Position " + string(occurrences[i]))
            set i to i + 1
    else:
        io.println("No occurrences found")

    logging.info(logger, "Search operations completed")

# String transformation operations
define function transformation_demo that takes logger as Logger:
    io.println("\n🔄 String Transformation")

    io.print("Enter text to transform: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to "hello world example"

    io.println("Original: '" + text + "'")
    io.println("─" * 40)

    # Case transformations
    io.println("Uppercase: '" + string.uppercase(text) + "'")
    io.println("Lowercase: '" + string.lowercase(text) + "'")
    io.println("Title case: '" + to_title_case(text) + "'")
    io.println("Toggle case: '" + toggle_case(text) + "'")

    # Reverse
    io.println("Reversed: '" + reverse_string(text) + "'")

    # Word reversal
    create words as List
    set words to string.split(text, " ")
    create reversed_words as List
    set reversed_words to reverse_list(words)
    create reversed_text as String
    set reversed_text to string.join(reversed_words, " ")
    io.println("Words reversed: '" + reversed_text + "'")

    logging.info(logger, "String transformations completed")

# String formatting
define function formatting_demo that takes logger as Logger:
    io.println("\n📄 String Formatting")

    io.println("1. Simple concatenation")
    io.println("2. Template formatting")
    io.println("3. Padding and alignment")
    io.println("4. Number formatting")
    io.print("Choose formatting type (1-4): ")

    create choice as String
    set choice to io.read_line()

    if choice == "1":
        io.print("Enter first name: ")
        create first_name as String
        set first_name to io.read_line()

        io.print("Enter last name: ")
        create last_name as String
        set last_name to io.read_line()

        create full_name as String
        set full_name to first_name + " " + last_name
        io.println("Full name: " + full_name)

    else if choice == "2":
        create template as String
        set template to "Hello, {name}! Welcome to {place}."
        io.println("Template: " + template)

        create formatted as String
        set formatted to string.replace(template, "{name}", "Alice")
        set formatted to string.replace(formatted, "{place}", "Wonderland")
        io.println("Formatted: " + formatted)

    else if choice == "3":
        create items as List
        set items to ["Apple", "Banana", "Cherry", "Date"]

        io.println("Left-aligned (width 10):")
        create i as Integer
        set i to 0
        while i < length(items):
            io.println("  '" + pad_right(items[i], 10) + "'")
            set i to i + 1

        io.println("\nRight-aligned (width 10):")
        set i to 0
        while i < length(items):
            io.println("  '" + pad_left(items[i], 10) + "'")
            set i to i + 1

    else if choice == "4":
        io.print("Enter a number: ")
        create num_str as String
        set num_str to io.read_line()
        create num as Float
        set num to float(num_str)

        io.println("Formatted numbers:")
        io.println("  Default: " + string(num))
        io.println("  2 decimals: " + format_number(num, 2))
        io.println("  Scientific: " + to_scientific_notation(num))

    logging.info(logger, "String formatting completed")

# Text parsing and extraction
define function parsing_demo that takes logger as Logger:
    io.println("\n🔧 Text Parsing & Extraction")

    io.println("1. Parse CSV data")
    io.println("2. Extract URLs from text")
    io.println("3. Parse HTML tags")
    io.println("4. Extract email addresses")
    io.print("Choose parsing type (1-4): ")

    create choice as String
    set choice to io.read_line()

    if choice == "1":
        create csv_data as String
        set csv_data to "Name,Age,City\nJohn,25,New York\nJane,30,Los Angeles"
        io.println("CSV Data:")
        io.println(csv_data)
        io.println("\nParsed:")

        create lines as List
        set lines to string.split(csv_data, "\n")
        create i as Integer
        set i to 0
        while i < length(lines):
            create fields as List
            set fields to string.split(lines[i], ",")
            io.println("  Row " + string(i + 1) + ": " + string.join(fields, " | "))
            set i to i + 1

    else if choice == "2":
        create text_with_urls as String
        set text_with_urls to "Visit https://example.com and http://test.org for more info."
        io.println("Text: " + text_with_urls)

        create urls as List
        set urls to extract_urls(text_with_urls)
        io.println("Extracted URLs:")
        create i as Integer
        set i to 0
        while i < length(urls):
            io.println("  " + urls[i])
            set i to i + 1

    else if choice == "3":
        create html as String
        set html to SAMPLE_HTML
        io.println("HTML: " + html)

        create tags as List
        set tags to extract_html_tags(html)
        io.println("Extracted tags:")
        create i as Integer
        set i to 0
        while i < length(tags):
            io.println("  " + tags[i])
            set i to i + 1

    else if choice == "4":
        create text_with_emails as String
        set text_with_emails to "Contact us at info@example.com or support@test.org"
        io.println("Text: " + text_with_emails)

        create emails as List
        set emails to extract_emails(text_with_emails)
        io.println("Extracted emails:")
        create i as Integer
        set i to 0
        while i < length(emails):
            io.println("  " + emails[i])
            set i to i + 1

    logging.info(logger, "Text parsing completed")

# Encoding and decoding
define function encoding_demo that takes logger as Logger:
    io.println("\n🔐 Encoding & Decoding")

    io.print("Enter text to encode: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to "Hello, 世界!"

    io.println("Original text: '" + text + "'")
    io.println("─" * 40)

    # Base64 encoding/decoding
    io.println("Base64 Encoding:")
    create b64_encoded as String
    set b64_encoded to base64_encode(text)
    io.println("  Encoded: " + b64_encoded)

    create b64_decoded as String
    set b64_decoded to base64_decode(b64_encoded)
    io.println("  Decoded: '" + b64_decoded + "'")

    # Hex encoding/decoding
    io.println("\nHex Encoding:")
    create hex_encoded as String
    set hex_encoded to hex_encode(text)
    io.println("  Encoded: " + hex_encoded)

    create hex_decoded as String
    set hex_decoded to hex_decode(hex_encoded)
    io.println("  Decoded: '" + hex_decoded + "'")

    # URL encoding
    create url_text as String
    set url_text to "Hello World & Special Characters!"
    io.println("\nURL Encoding:")
    io.println("  Original: " + url_text)
    create url_encoded as String
    set url_encoded to url_encode(url_text)
    io.println("  Encoded: " + url_encoded)

    logging.info(logger, "Encoding/decoding operations completed")

# String validation
define function validation_demo that takes logger as Logger:
    io.println("\n✅ String Validation")

    io.println("1. Email validation")
    io.println("2. Phone number validation")
    io.println("3. Password strength check")
    io.println("4. Numeric validation")
    io.print("Choose validation type (1-4): ")

    create choice as String
    set choice to io.read_line()

    if choice == "1":
        create test_emails as List
        set test_emails to ["user@example.com", "invalid.email", "test@domain", "user@domain.co.uk"]

        io.println("Email Validation:")
        create i as Integer
        set i to 0
        while i < length(test_emails):
            create email as String
            set email to test_emails[i]
            create is_valid as Boolean
            set is_valid to is_valid_email(email)
            io.println("  '" + email + "': " + (is_valid ? "Valid" : "Invalid"))
            set i to i + 1

    else if choice == "2":
        create test_phones as List
        set test_phones to ["123-456-7890", "(555) 123-4567", "555.123.4567", "1234567890", "invalid"]

        io.println("Phone Validation:")
        create i as Integer
        set i to 0
        while i < length(test_phones):
            create phone as String
            set phone to test_phones[i]
            create is_valid as Boolean
            set is_valid to is_valid_phone(phone)
            io.println("  '" + phone + "': " + (is_valid ? "Valid" : "Invalid"))
            set i to i + 1

    else if choice == "3":
        create test_passwords as List
        set test_passwords to ["weak", "Stronger123", "VeryStrong123!", "123456", "P@ssw0rd!"]

        io.println("Password Strength Check:")
        create i as Integer
        set i to 0
        while i < length(test_passwords):
            create password as String
            set password to test_passwords[i]
            create strength as String
            set strength to check_password_strength(password)
            io.println("  '" + password + "': " + strength)
            set i to i + 1

    else if choice == "4":
        create test_numbers as List
        set test_numbers to ["123", "123.45", "-789", "3.14", "not-a-number", "1e10"]

        io.println("Numeric Validation:")
        create i as Integer
        set i to 0
        while i < length(test_numbers):
            create num_str as String
            set num_str to test_numbers[i]
            create is_valid as Boolean
            set is_valid to is_numeric(num_str)
            io.println("  '" + num_str + "': " + (is_valid ? "Valid" : "Invalid"))
            set i to i + 1

    logging.info(logger, "String validation completed")

# Text processing utilities
define function text_processing_demo that takes logger as Logger:
    io.println("\n⚙️ Text Processing Utilities")

    io.print("Enter text to process: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to "This   is   a    sample   text   with   multiple   spaces."

    io.println("Original: '" + text + "'")
    io.println("─" * 50)

    # Whitespace operations
    create trimmed as String
    set trimmed to string.trim(text)
    io.println("Trimmed: '" + trimmed + "'")

    create normalized_spaces as String
    set normalized_spaces to normalize_whitespace(text)
    io.println("Normalized spaces: '" + normalized_spaces + "'")

    # Word operations
    create words as List
    set words to string.split(normalized_spaces, " ")
    io.println("Unique words: " + string(length(get_unique_words(words))))

    # Character operations
    create no_punctuation as String
    set no_punctuation to remove_punctuation(text)
    io.println("Without punctuation: '" + no_punctuation + "'")

    create word_count as Integer
    set word_count to length(words)
    create char_count as Integer
    set char_count to string.length(text)
    create avg_chars_per_word as Float
    set avg_chars_per_word to char_count / word_count
    io.println("Average characters per word: " + string(avg_chars_per_word))

    logging.info(logger, "Text processing completed")

# Regular expressions
define function regex_demo that takes logger as Logger:
    io.println("\n🔗 Regular Expressions")

    io.print("Enter text to search: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to "The price is $19.99 and the code is ABC123."

    io.print("Enter regex pattern: ")
    create pattern as String
    set pattern to io.read_line()

    if pattern == "":
        set pattern to "\\$\\d+\\.\\d{2}"  # Match dollar amounts

    io.println("Text: '" + text + "'")
    io.println("Pattern: '" + pattern + "'")
    io.println("─" * 50)

    # Basic regex operations
    create matches as List
    set matches to regex.find_all(text, pattern)

    if length(matches) > 0:
        io.println("Found " + string(length(matches)) + " matches:")
        create i as Integer
        set i to 0
        while i < length(matches):
            io.println("  " + string(i + 1) + ": '" + matches[i] + "'")
            set i to i + 1
    else:
        io.println("No matches found")

    # Common regex patterns
    io.println("\nCommon Patterns:")
    io.println("  Email: " + string(length(regex.find_all(text, "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"))))
    io.println("  Numbers: " + string(length(regex.find_all(text, "\\d+"))))
    io.println("  Words: " + string(length(regex.find_all(text, "\\b\\w+\\b"))))

    logging.info(logger, "Regex operations completed")

# Helper functions for analysis
define function count_occurrences that takes text as String, pattern as String and returns Integer:
    create count as Integer
    set count to 0
    create pos as Integer
    set pos to 0

    while true:
        create found_pos as Integer
        set found_pos to find_substring(text, pattern, pos)
        if found_pos == -1:
            break
        set count to count + 1
        set pos to found_pos + 1

    return count

define function calculate_average_word_length that takes words as List and returns Float:
    if length(words) == 0:
        return 0.0

    create total_length as Integer
    set total_length to 0
    create i as Integer
    set i to 0
    while i < length(words):
        set total_length to total_length + string.length(words[i])
        set i to i + 1

    return total_length / length(words)

define function analyze_character_frequency that takes text as String and returns Object:
    create freq as Object
    set freq to {}

    create i as Integer
    set i to 0
    while i < string.length(text):
        create char as String
        set char to substring(text, i, 1)
        if freq[char] is not defined:
            set freq[char] to 0
        set freq[char] to freq[char] + 1
        set i to i + 1

    return freq

define function get_object_keys that takes obj as Object and returns List:
    create keys as List
    set keys to []
    # This would need to be implemented based on the object structure
    return keys

# Helper functions for search
define function find_all_occurrences that takes text as String, pattern as String and returns List:
    create occurrences as List
    set occurrences to []
    create pos as Integer
    set pos to 0

    while true:
        create found_pos as Integer
        set found_pos to find_substring(text, pattern, pos)
        if found_pos == -1:
            break
        add found_pos to occurrences
        set pos to found_pos + 1

    return occurrences

define function find_substring that takes text as String, pattern as String, start_pos as Integer and returns Integer:
    create text_len as Integer
    set text_len to string.length(text)
    create pattern_len as Integer
    set pattern_len to string.length(pattern)

    if pattern_len == 0:
        return start_pos

    create i as Integer
    set i to start_pos
    while i <= text_len - pattern_len:
        create j as Integer
        set j to 0
        while j < pattern_len:
            if substring(text, i + j, 1) != substring(pattern, j, 1):
                break
            set j to j + 1

        if j == pattern_len:
            return i
        set i to i + 1

    return -1

# Helper functions for transformation
define function to_title_case that takes text as String and returns String:
    create words as List
    set words to string.split(text, " ")
    create result_words as List
    set result_words to []

    create i as Integer
    set i to 0
    while i < length(words):
        create word as String
        set word to words[i]
        if string.length(word) > 0:
            create first_char as String
            set first_char to substring(word, 0, 1)
            create rest as String
            set rest to substring(word, 1, string.length(word) - 1)
            set word to string.uppercase(first_char) + string.lowercase(rest)
        add word to result_words
        set i to i + 1

    return string.join(result_words, " ")

define function toggle_case that takes text as String and returns String:
    create result as String
    set result to ""

    create i as Integer
    set i to 0
    while i < string.length(text):
        create char as String
        set char to substring(text, i, 1)
        create upper_char as String
        set upper_char to string.uppercase(char)
        create lower_char as String
        set lower_char to string.lowercase(char)

        if char == upper_char:
            set result to result + lower_char
        else:
            set result to result + upper_char
        set i to i + 1

    return result

define function reverse_string that takes text as String and returns String:
    create result as String
    set result to ""

    create i as Integer
    set i to string.length(text) - 1
    while i >= 0:
        create char as String
        set char to substring(text, i, 1)
        set result to result + char
        set i to i - 1

    return result

define function reverse_list that takes items as List and returns List:
    create result as List
    set result to []

    create i as Integer
    set i to length(items) - 1
    while i >= 0:
        add items[i] to result
        set i to i - 1

    return result

# Helper functions for formatting
define function pad_right that takes text as String, width as Integer and returns String:
    while string.length(text) < width:
        set text to text + " "
    return text

define function pad_left that takes text as String, width as Integer and returns String:
    while string.length(text) < width:
        set text to " " + text
    return text

define function format_number that takes num as Float, decimals as Integer and returns String:
    create factor as Float
    set factor to power(10, decimals)
    create rounded as Integer
    set rounded to int(num * factor + 0.5)
    create result as String
    set result to string(rounded / factor)

    # Add trailing zeros if needed
    create dot_pos as Integer
    set dot_pos to find_substring(result, ".", 0)
    if dot_pos == -1:
        set result to result + "."
        set dot_pos to string.length(result) - 1

    while string.length(substring(result, dot_pos + 1, string.length(result) - dot_pos - 1)) < decimals:
        set result to result + "0"

    return result

define function to_scientific_notation that takes num as Float and returns String:
    if num == 0:
        return "0e0"

    create sign as String
    set sign to ""
    if num < 0:
        set sign to "-"
        set num to -num

    create exponent as Integer
    set exponent to 0

    while num >= 10:
        set num to num / 10
        set exponent to exponent + 1

    while num < 1:
        set num to num * 10
        set exponent to exponent - 1

    return sign + format_number(num, 3) + "e" + string(exponent)

# Helper functions for parsing
define function extract_urls that takes text as String and returns List:
    # Simple URL extraction (could be improved with proper regex)
    create urls as List
    set urls to []

    create words as List
    set words to string.split(text, " ")
    create i as Integer
    set i to 0
    while i < length(words):
        create word as String
        set word to words[i]
        if string.starts_with(word, "http://") or string.starts_with(word, "https://"):
            add word to urls
        set i to i + 1

    return urls

define function extract_html_tags that takes html as String and returns List:
    create tags as List
    set tags to []
    create i as Integer
    set i to 0

    while i < string.length(html):
        if substring(html, i, 1) == "<":
            create tag_start as Integer
            set tag_start to i
            set i to i + 1

            while i < string.length(html) and substring(html, i, 1) != ">":
                set i to i + 1

            if i < string.length(html):
                create tag as String
                set tag to substring(html, tag_start, i - tag_start + 1)
                add tag to tags
        set i to i + 1

    return tags

define function extract_emails that takes text as String and returns List:
    # Simple email extraction (could be improved with proper regex)
    create emails as List
    set emails to []

    create words as List
    set words to string.split(text, " ")
    create i as Integer
    set i to 0
    while i < length(words):
        create word as String
        set word to words[i]
        if string.contains(word, "@") and string.contains(word, "."):
            add word to emails
        set i to i + 1

    return emails

# Helper functions for encoding
define function base64_encode that takes text as String and returns String:
    # Placeholder implementation
    return "BASE64_ENCODED_" + text

define function base64_decode that takes encoded as String and returns String:
    # Placeholder implementation
    if string.starts_with(encoded, "BASE64_ENCODED_"):
        return substring(encoded, 15, string.length(encoded) - 15)
    return encoded

define function hex_encode that takes text as String and returns String:
    # Placeholder implementation
    return "HEX_ENCODED_" + text

define function hex_decode that takes encoded as String and returns String:
    # Placeholder implementation
    if string.starts_with(encoded, "HEX_ENCODED_"):
        return substring(encoded, 12, string.length(encoded) - 12)
    return encoded

define function url_encode that takes text as String and returns String:
    # Simple URL encoding
    create result as String
    set result to ""
    create i as Integer
    set i to 0
    while i < string.length(text):
        create char as String
        set char to substring(text, i, 1)
        if char == " ":
            set result to result + "%20"
        else if char == "&":
            set result to result + "%26"
        else if char == "!":
            set result to result + "%21"
        else:
            set result to result + char
        set i to i + 1
    return result

# Helper functions for validation
define function is_valid_email that takes email as String and returns Boolean:
    if not string.contains(email, "@"):
        return false
    if not string.contains(email, "."):
        return false
    if string.length(email) < 5:
        return false

    create parts as List
    set parts to string.split(email, "@")
    if length(parts) != 2:
        return false

    create domain_parts as List
    set domain_parts to string.split(parts[1], ".")
    if length(domain_parts) < 2:
        return false

    return true

define function is_valid_phone that takes phone as String and returns Boolean:
    # Remove common separators
    create clean_phone as String
    set clean_phone to ""
    create i as Integer
    set i to 0
    while i < string.length(phone):
        create char as String
        set char to substring(phone, i, 1)
        if char >= "0" and char <= "9":
            set clean_phone to clean_phone + char
        set i to i + 1

    return string.length(clean_phone) == 10 or string.length(clean_phone) == 11

define function check_password_strength that takes password as String and returns String:
    if string.length(password) < 6:
        return "Weak"

    create has_upper as Boolean
    set has_upper to false
    create has_lower as Boolean
    set has_lower to false
    create has_digit as Boolean
    set has_digit to false
    create has_special as Boolean
    set has_special to false

    create i as Integer
    set i to 0
    while i < string.length(password):
        create char as String
        set char to substring(password, i, 1)
        if char >= "A" and char <= "Z":
            set has_upper to true
        else if char >= "a" and char <= "z":
            set has_lower to true
        else if char >= "0" and char <= "9":
            set has_digit to true
        else:
            set has_special to true
        set i to i + 1

    create score as Integer
    set score to 0
    if has_upper:
        set score to score + 1
    if has_lower:
        set score to score + 1
    if has_digit:
        set score to score + 1
    if has_special:
        set score to score + 1
    if string.length(password) >= 8:
        set score to score + 1

    if score >= 5:
        return "Very Strong"
    else if score >= 4:
        return "Strong"
    else if score >= 2:
        return "Medium"
    else:
        return "Weak"

define function is_numeric that takes text as String and returns Boolean:
    if string.length(text) == 0:
        return false

    create has_dot as Boolean
    set has_dot to false
    create has_digit as Boolean
    set has_digit to false
    create i as Integer
    set i to 0

    if substring(text, 0, 1) == "-":
        set i to 1

    while i < string.length(text):
        create char as String
        set char to substring(text, i, 1)
        if char == ".":
            if has_dot:
                return false
            set has_dot to true
        else if char >= "0" and char <= "9":
            set has_digit to true
        else:
            return false
        set i to i + 1

    return has_digit

# Helper functions for text processing
define function normalize_whitespace that takes text as String and returns String:
    create result as String
    set result to ""
    create in_whitespace as Boolean
    set in_whitespace to false

    create i as Integer
    set i to 0
    while i < string.length(text):
        create char as String
        set char to substring(text, i, 1)
        if char == " " or char == "\t" or char == "\n":
            if not in_whitespace:
                set result to result + " "
                set in_whitespace to true
        else:
            set result to result + char
            set in_whitespace to false
        set i to i + 1

    return string.trim(result)

define function get_unique_words that takes words as List and returns List:
    create unique as List
    set unique to []
    create seen as List
    set seen to []

    create i as Integer
    set i to 0
    while i < length(words):
        create word as String
        set word to words[i]
        create is_duplicate as Boolean
        set is_duplicate to false
        create j as Integer
        set j to 0
        while j < length(seen):
            if seen[j] == word:
                set is_duplicate to true
                break
            set j to j + 1

        if not is_duplicate:
            add word to seen
            add word to unique
        set i to i + 1

    return unique

define function remove_punctuation that takes text as String and returns String:
    create result as String
    set result to ""

    create i as Integer
    set i to 0
    while i < string.length(text):
        create char as String
        set char to substring(text, i, 1)
        if (char >= "a" and char <= "z") or (char >= "A" and char <= "Z") or (char >= "0" and char <= "9") or char == " ":
            set result to result + char
        set i to i + 1

    return result

define function substring that takes text as String, start as Integer, length as Integer and returns String:
    # Placeholder for substring function
    return "substring_placeholder"

define function power that takes base as Float, exponent as Float and returns Float:
    if exponent == 0:
        return 1.0
    if exponent == 1:
        return base

    create result as Float
    set result to 1.0
    create i as Integer
    set i to 0
    while i < int(exponent):
        set result to result * base
        set i to i + 1

    return result

# Initialize the application
main()