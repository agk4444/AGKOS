# AGK Bootloader Template
# A simple bootloader for x86 systems

import hardware
import kernel

# Bootloader constants
create BOOTLOADER_ADDRESS as Integer
create KERNEL_ADDRESS as Integer
create STACK_ADDRESS as Integer
create VIDEO_MEMORY as Integer

set BOOTLOADER_ADDRESS to 0x7C00
set KERNEL_ADDRESS to 0x100000
set STACK_ADDRESS to 0x9FC00
set VIDEO_MEMORY to 0xB8000

define function bootloader_entry:
    """Bootloader entry point"""
    # Disable interrupts during setup
    disable_interrupts()

    # Set up segment registers
    set_ds(0x0000)
    set_es(0x0000)
    set_ss(0x0000)
    set_sp(STACK_ADDRESS)

    # Clear screen and show boot message
    clear_screen()
    print_string("AGK Bootloader v1.0", 0, 0, 0x0A)
    print_string("Loading kernel...", 0, 1, 0x07)

    # Initialize hardware
    if not initialize_hardware():
        print_string("Hardware initialization failed!", 0, 2, 0x0C)
        halt_system()

    # Load kernel from disk
    if not load_kernel():
        print_string("Kernel loading failed!", 0, 3, 0x0C)
        halt_system()

    # Enable A20 line for memory access above 1MB
    if not enable_a20():
        print_string("A20 enable failed!", 0, 4, 0x0C)
        halt_system()

    # Switch to protected mode
    if not switch_to_protected_mode():
        print_string("Protected mode switch failed!", 0, 5, 0x0C)
        halt_system()

    # Jump to kernel
    print_string("Starting kernel...", 0, 6, 0x0A)
    jump_to_kernel()

define function clear_screen:
    """Clear the screen"""
    create i as Integer
    set i to 0
    while i < 80 * 25 * 2:
        write_memory_byte(VIDEO_MEMORY + i, 0)
        set i to i + 1

define function print_string(text as String, x as Integer, y as Integer, color as Integer):
    """Print string to screen"""
    create offset as Integer
    set offset to (y * 80 + x) * 2

    create i as Integer
    set i to 0
    while i < length(text):
        create char as Integer
        set char to text[i]

        write_memory_byte(VIDEO_MEMORY + offset, char)
        write_memory_byte(VIDEO_MEMORY + offset + 1, color)
        set offset to offset + 2
        set i to i + 1

define function initialize_hardware:
    """Initialize basic hardware"""
    # Reset disk system
    outb(0x3F2, 0x00)  # Reset floppy
    outb(0x3F2, 0x0C)  # Enable motor

    # Initialize PIC (Programmable Interrupt Controller)
    outb(0x20, 0x11)  # ICW1: Edge triggered, cascade mode
    outb(0xA0, 0x11)
    outb(0x21, 0x20)  # ICW2: Master PIC vector base
    outb(0xA1, 0x28)  # ICW2: Slave PIC vector base
    outb(0x21, 0x04)  # ICW3: Master-slave relationship
    outb(0xA1, 0x02)
    outb(0x21, 0x01)  # ICW4: 8086 mode
    outb(0xA1, 0x01)

    # Mask all interrupts except timer and keyboard
    outb(0x21, 0xFC)  # Master PIC mask
    outb(0xA1, 0xFF)  # Slave PIC mask

    return true

define function load_kernel:
    """Load kernel from disk"""
    # This is a simplified version - real bootloader would handle
    # FAT file system and load kernel image from disk

    print_string("Loading kernel sectors...", 0, 7, 0x07)

    # Read kernel sectors (simplified - no error checking)
    create sector as Integer
    set sector to 1  # Kernel starts at sector 1

    while sector <= 64:  # Load 64 sectors (32KB)
        if not read_sector(sector, KERNEL_ADDRESS + (sector - 1) * 512):
            return false
        set sector to sector + 1

    print_string("Kernel loaded successfully", 0, 8, 0x0A)
    return true

define function read_sector(sector as Integer, address as Integer):
    """Read a sector from disk (simplified)"""
    # Wait for disk to be ready
    create timeout as Integer
    set timeout to 0

    while timeout < 1000:
        if (inb(0x1F7) & 0xC0) == 0x40:
            break
        set timeout to timeout + 1

    if timeout >= 1000:
        return false

    # Send read command
    outb(0x1F6, 0xE0 | ((sector >> 24) & 0x0F))  # Drive and head
    outb(0x1F2, 1)                               # Sector count
    outb(0x1F3, sector & 0xFF)                   # Sector number
    outb(0x1F4, (sector >> 8) & 0xFF)            # Cylinder low
    outb(0x1F5, (sector >> 16) & 0xFF)           # Cylinder high
    outb(0x1F7, 0x20)                            # Read command

    # Wait for data
    set timeout to 0
    while timeout < 1000:
        if (inb(0x1F7) & 0x08) != 0:
            break
        set timeout to timeout + 1

    if timeout >= 1000:
        return false

    # Read sector data
    create i as Integer
    set i to 0
    while i < 256:  # 256 words = 512 bytes
        create word as Integer
        set word to inw(0x1F0)
        write_memory_word(address + i * 2, word)
        set i to i + 1

    return true

define function enable_a20:
    """Enable A20 line for memory access above 1MB"""
    print_string("Enabling A20 line...", 0, 9, 0x07)

    # Method 1: Keyboard controller
    outb(0x64, 0xAD)  # Disable keyboard
    outb(0x64, 0xD0)  # Read output port
    create status as Integer
    set status to inb(0x60)
    outb(0x64, 0xD1)  # Write output port
    outb(0x60, status | 0x02)  # Enable A20
    outb(0x64, 0xAE)  # Enable keyboard

    # Method 2: Fast A20
    outb(0x92, inb(0x92) | 0x02)

    # Test A20
    if test_a20():
        print_string("A20 enabled", 0, 10, 0x0A)
        return true
    else:
        print_string("A20 failed", 0, 10, 0x0C)
        return false

define function test_a20:
    """Test if A20 line is enabled"""
    # Write different values to 0x0000 and 0x100000
    write_memory_byte(0x0000, 0x00)
    write_memory_byte(0x100000, 0xFF)

    if read_memory_byte(0x0000) == read_memory_byte(0x100000):
        return false  # A20 not enabled

    write_memory_byte(0x0000, 0xFF)
    write_memory_byte(0x100000, 0x00)

    if read_memory_byte(0x0000) == read_memory_byte(0x100000):
        return false  # A20 not enabled

    return true

define function switch_to_protected_mode:
    """Switch to protected mode"""
    print_string("Switching to protected mode...", 0, 11, 0x07)

    # Load GDT
    load_gdt()

    # Enable protected mode
    set_cr0(get_cr0() | 0x00000001)

    # Far jump to reload CS register
    far_jump(0x08, protected_mode_entry)

    return true

define function protected_mode_entry:
    """Entry point after switching to protected mode"""
    # Set up segment registers for protected mode
    set_ds(0x10)
    set_es(0x10)
    set_ss(0x10)

    print_string("Protected mode enabled", 0, 12, 0x0A)
    return true

define function jump_to_kernel:
    """Jump to loaded kernel"""
    print_string("Jumping to kernel...", 0, 13, 0x0A)

    # Simple far jump to kernel
    far_jump(0x08, KERNEL_ADDRESS)

define function halt_system:
    """Halt the system"""
    print_string("System halted", 0, 24, 0x0C)
    disable_interrupts()
    while true:
        halt_cpu()

# Low-level assembly functions (implemented in hardware library)
external function set_ds(value as Integer) from "hardware.so" as void
external function set_es(value as Integer) from "hardware.so" as void
external function set_ss(value as Integer) from "hardware.so" as void
external function set_sp(value as Integer) from "hardware.so" as void
external function get_cr0() from "hardware.so" as Integer
external function set_cr0(value as Integer) from "hardware.so" as void
external function far_jump(segment as Integer, offset as Integer) from "hardware.so" as void
external function load_gdt() from "hardware.so" as void
external function write_memory_byte(address as Integer, value as Integer) from "hardware.so" as void
external function read_memory_byte(address as Integer) from "hardware.so" as Integer
external function write_memory_word(address as Integer, value as Integer) from "hardware.so" as void
external function read_memory_word(address as Integer) from "hardware.so" as Integer

# Bootloader padding and signature
# This would be filled to make the bootloader exactly 512 bytes
# with the boot signature 0xAA55 at the end