# AGK Wearable Device Application Template
# Cross-platform wearable app with health monitoring, notifications, and AR features
# Perfect for: Fitness Apps, Health Monitoring, Smartwatch Apps, AR Glasses Apps

import graphics
import io
import string
import math
import date
import wearable

# Wearable app configuration
create screen_width as Integer
set screen_width to 400  # Standard smartwatch width

create screen_height as Integer
set screen_height to 400  # Standard smartwatch height (square display)

create app_name as String
set app_name to "AGK Wearable App"

# App state
create current_screen as String
set current_screen to "home"

create heart_rate_session as Integer
set heart_rate_session to 0

create step_session as Integer
set step_session to 0

create ar_session as Integer
set ar_session to 0

# Health data
create current_heart_rate as Integer
set current_heart_rate to 0

create daily_steps as Integer
set daily_steps to 0

create calories_burned as Float
set calories_burned to 0.0

# Notification data
create notifications as Object
create notification_count as Integer
set notification_count to 0

# AR data
create ar_active as Boolean
set ar_active to false

create ar_content as List

define function main:
    # Initialize wearable app
    create window as graphics.Window
    set window to graphics.create_window(screen_width, screen_height, app_name)

    # Create drawing canvas
    create canvas as graphics.Canvas
    set canvas to graphics.create_canvas(screen_width, screen_height)

    # Initialize wearable sensors
    initialize_wearable_sensors()

    # Main app loop
    create running as Boolean
    set running to true

    while running:
        # Handle wearable input (touch, gestures, crown)
        create input_events as Object
        set input_events to handle_wearable_input()

        if input_events:
            handle_touch_input(input_events)
            handle_gesture_input(input_events)
            handle_crown_input(input_events)

        # Update health data
        update_health_data()

        # Update notifications
        update_notifications()

        # Clear canvas with app background
        graphics.draw_rectangle(canvas, 0, 0, screen_width, screen_height, graphics.color_black(), true)

        # Draw current screen
        if current_screen is equal to "home":
            draw_home_screen(canvas)
        else:
            if current_screen is equal to "health":
                draw_health_screen(canvas)
            else:
                if current_screen is equal to "notifications":
                    draw_notifications_screen(canvas)
                else:
                    if current_screen is equal to "ar":
                        draw_ar_screen(canvas)

        # Draw watch face elements
        draw_watch_frame(canvas)
        draw_time_display(canvas)
        draw_battery_indicator(canvas)

        # Update display
        # graphics.render_canvas_to_window(canvas, window)

        # Check for app exit
        if is_button_pressed(350, 350, 50, 50):  # Back button area
            set running to false

    # Cleanup
    cleanup_wearable_sensors()
    graphics.close_window(window)
    io.print("Wearable app ended")
    return 0

# Screen drawing functions
define function draw_home_screen that takes canvas as Canvas:
    # Center content for round watch face
    create center_x as Integer
    set center_x to screen_width / 2
    create center_y as Integer
    set center_y to screen_height / 2

    # Time display (large)
    create current_time as String
    set current_time to date.get_current_time()
    graphics.draw_text(canvas, center_x - 60, center_y - 80, current_time, graphics.color_white(), 24)

    # Health summary
    graphics.draw_text(canvas, center_x - 80, center_y - 20, "❤️ " + string.format(current_heart_rate), graphics.color_red(), 16)
    graphics.draw_text(canvas, center_x - 80, center_y + 10, "👣 " + string.format(daily_steps), graphics.color_blue(), 16)

    # Quick actions (positioned for circular touch)
    # Top
    if is_button_touched_circular(center_x, center_y - 120, 40):
        graphics.draw_circle(canvas, center_x, center_y - 120, 40, graphics.color_green(), true)
    else:
        graphics.draw_circle(canvas, center_x, center_y - 120, 40, graphics.color_gray(), true)
    graphics.draw_text(canvas, center_x - 15, center_y - 125, "🏥", graphics.color_white(), 20)

    # Bottom
    if is_button_touched_circular(center_x, center_y + 120, 40):
        graphics.draw_circle(canvas, center_x, center_y + 120, 40, graphics.color_blue(), true)
    else:
        graphics.draw_circle(canvas, center_x, center_y + 120, 40, graphics.color_gray(), true)
    graphics.draw_text(canvas, center_x - 15, center_y + 115, "🔔", graphics.color_white(), 20)

    # Left
    if is_button_touched_circular(center_x - 120, center_y, 40):
        graphics.draw_circle(canvas, center_x - 120, center_y, 40, graphics.color_purple(), true)
    else:
        graphics.draw_circle(canvas, center_x - 120, center_y, 40, graphics.color_gray(), true)
    graphics.draw_text(canvas, center_x - 135, center_y - 5, "AR", graphics.color_white(), 16)

    # Right
    if is_button_touched_circular(center_x + 120, center_y, 40):
        graphics.draw_circle(canvas, center_x + 120, center_y, 40, graphics.color_orange(), true)
    else:
        graphics.draw_circle(canvas, center_x + 120, center_y, 40, graphics.color_gray(), true)
    graphics.draw_text(canvas, center_x + 105, center_y - 5, "⚙️", graphics.color_white(), 16)

define function draw_health_screen that takes canvas as Canvas:
    # Health monitoring screen
    graphics.draw_text(canvas, 20, 30, "Health Monitor", graphics.color_white(), 20)

    # Heart rate display
    graphics.draw_rectangle(canvas, 20, 60, screen_width - 40, 80, graphics.color_red(), false)
    graphics.draw_text(canvas, 30, 70, "Heart Rate", graphics.color_red(), 16)
    graphics.draw_text(canvas, 30, 90, string.format(current_heart_rate) + " BPM", graphics.color_white(), 18)

    # Steps display
    graphics.draw_rectangle(canvas, 20, 160, screen_width - 40, 80, graphics.color_blue(), false)
    graphics.draw_text(canvas, 30, 170, "Daily Steps", graphics.color_blue(), 16)
    graphics.draw_text(canvas, 30, 190, string.format(daily_steps) + " steps", graphics.color_white(), 18)

    # Calories display
    graphics.draw_rectangle(canvas, 20, 260, screen_width - 40, 80, graphics.color_green(), false)
    graphics.draw_text(canvas, 30, 270, "Calories Burned", graphics.color_green(), 16)
    graphics.draw_text(canvas, 30, 290, string.format(calories_burned) + " kcal", graphics.color_white(), 18)

    # Start/Stop monitoring button
    if heart_rate_session > 0:
        graphics.draw_rectangle(canvas, 20, 350, screen_width - 40, 40, graphics.color_red(), true)
        graphics.draw_text(canvas, screen_width / 2 - 40, 360, "Stop Monitoring", graphics.color_white(), 16)
    else:
        graphics.draw_rectangle(canvas, 20, 350, screen_width - 40, 40, graphics.color_green(), true)
        graphics.draw_text(canvas, screen_width / 2 - 35, 360, "Start Monitoring", graphics.color_white(), 16)

define function draw_notifications_screen that takes canvas as Canvas:
    # Notifications screen
    graphics.draw_text(canvas, 20, 30, "Notifications", graphics.color_white(), 20)

    # Notification list
    create y_pos as Integer
    set y_pos to 60

    for i from 0 to notification_count - 1:
        if y_pos > screen_height - 80:
            break

        graphics.draw_rectangle(canvas, 20, y_pos, screen_width - 40, 50, graphics.color_gray(), true)
        graphics.draw_text(canvas, 30, y_pos + 10, "Notification " + string.format(i + 1), graphics.color_white(), 14)
        graphics.draw_text(canvas, 30, y_pos + 30, "Sample notification text", graphics.color_gray(), 12)

        set y_pos to y_pos + 60

    # Clear notifications button
    if notification_count > 0:
        graphics.draw_rectangle(canvas, 20, screen_height - 60, screen_width - 40, 40, graphics.color_red(), true)
        graphics.draw_text(canvas, screen_width / 2 - 50, screen_height - 50, "Clear All", graphics.color_white(), 16)

define function draw_ar_screen that takes canvas as Canvas:
    # AR glasses screen
    graphics.draw_text(canvas, 20, 30, "AR Mode", graphics.color_white(), 20)

    if ar_active:
        graphics.draw_text(canvas, 20, 60, "AR Active - Look around!", graphics.color_green(), 16)

        # Simulate AR content overlay
        for content in ar_content:
            create x as Float
            set x to content["x"]
            create y as Float
            set y to content["y"]
            create text as String
            set text to content["text"]

            graphics.draw_text(canvas, x, y, text, graphics.color_cyan(), 14)
    else:
        graphics.draw_text(canvas, 20, 60, "AR Inactive", graphics.color_red(), 16)

        # Start AR button
        graphics.draw_rectangle(canvas, 20, 100, screen_width - 40, 50, graphics.color_green(), true)
        graphics.draw_text(canvas, screen_width / 2 - 30, 115, "Start AR", graphics.color_white(), 18)

    # AR controls
    graphics.draw_rectangle(canvas, 20, screen_height - 60, screen_width - 40, 40, graphics.color_blue(), true)
    graphics.draw_text(canvas, screen_width / 2 - 40, screen_height - 50, "Calibrate", graphics.color_white(), 16)

define function draw_watch_frame that takes canvas as Canvas:
    # Draw circular watch face outline
    graphics.draw_circle(canvas, screen_width / 2, screen_height / 2, screen_width / 2 - 5, graphics.color_white(), false)

    # Crown indicator (for smartwatches with rotating crown)
    graphics.draw_rectangle(canvas, screen_width - 20, screen_height / 2 - 20, 15, 40, graphics.color_gray(), true)

define function draw_time_display that takes canvas as Canvas:
    # Time in corner (always visible)
    create time_text as String
    set time_text to date.get_current_time()
    graphics.draw_text(canvas, screen_width - 80, 20, time_text, graphics.color_white(), 12)

define function draw_battery_indicator that takes canvas as Canvas:
    # Battery indicator
    create battery_level as Float
    set battery_level to wearable.get_battery_level()

    create battery_width as Integer
    set battery_width to 30
    create battery_x as Integer
    set battery_x to 10

    graphics.draw_rectangle(canvas, battery_x, 10, battery_width, 15, graphics.color_white(), false)
    graphics.draw_rectangle(canvas, battery_x + battery_width, 13, 3, 9, graphics.color_white(), true)

    create fill_width as Integer
    set fill_width to battery_width * battery_level
    if battery_level > 0.2:
        graphics.draw_rectangle(canvas, battery_x, 10, fill_width, 15, graphics.color_green(), true)
    else:
        graphics.draw_rectangle(canvas, battery_x, 10, fill_width, 15, graphics.color_red(), true)

# Input handling functions
define function handle_wearable_input:
    create events as Object

    # Touch input
    create touch_coords as List
    set touch_coords to wearable.get_touch_coordinates()
    if touch_coords:
        set events["touch_x"] to touch_coords[0]
        set events["touch_y"] to touch_coords[1]
        set events["touch_active"] to wearable.is_touch_active()

    # Gesture recognition
    if wearable.is_gesture_supported():
        create gesture as String
        set gesture to wearable.get_recognized_gesture()
        if gesture:
            set events["gesture"] to gesture

    # Crown input
    if wearable.is_crown_supported():
        create crown_rotation as Float
        set crown_rotation to wearable.get_crown_rotation()
        if crown_rotation != 0:
            set events["crown_rotation"] to crown_rotation

    return events

define function handle_touch_input that takes events as Object:
    if events contains "touch_x" and events contains "touch_y" and events["touch_active"]:
        create x as Integer
        set x to events["touch_x"]
        create y as Integer
        set y to events["touch_y"]

        # Handle screen navigation
        if current_screen is equal to "home":
            handle_home_touch(x, y)
        else:
            if current_screen is equal to "health":
                handle_health_touch(x, y)
            else:
                if current_screen is equal to "ar":
                    handle_ar_touch(x, y)

define function handle_gesture_input that takes events as Object:
    if events contains "gesture":
        create gesture as String
        set gesture to events["gesture"]

        if gesture is equal to wearable.GESTURE_SWIPE_LEFT:
            navigate_screen("previous")
        else:
            if gesture is equal to wearable.GESTURE_SWIPE_RIGHT:
                navigate_screen("next")
            else:
                if gesture is equal to wearable.GESTURE_TAP:
                    handle_tap_gesture()

define function handle_crown_input that takes events as Object:
    if events contains "crown_rotation":
        create rotation as Float
        set rotation to events["crown_rotation"]

        # Use crown for scrolling or adjusting values
        if rotation > 0:
            scroll_up()
        else:
            scroll_down()

# Touch handling for specific screens
define function handle_home_touch that takes x as Integer, y as Integer:
    create center_x as Integer
    set center_x to screen_width / 2
    create center_y as Integer
    set center_y to screen_height / 2

    if is_point_in_circle(x, y, center_x, center_y - 120, 40):
        set current_screen to "health"
    else:
        if is_point_in_circle(x, y, center_x, center_y + 120, 40):
            set current_screen to "notifications"
        else:
            if is_point_in_circle(x, y, center_x - 120, center_y, 40):
                set current_screen to "ar"
            else:
                if is_point_in_circle(x, y, center_x + 120, center_y, 40):
                    set current_screen to "settings"

define function handle_health_touch that takes x as Integer, y as Integer:
    if is_button_touched(x, y, 20, 350, screen_width - 40, 40):
        if heart_rate_session > 0:
            wearable.stop_heart_rate_monitoring(heart_rate_session)
            set heart_rate_session to 0
        else:
            set heart_rate_session to wearable.start_heart_rate_monitoring()

define function handle_ar_touch that takes x as Integer, y as Integer:
    if not ar_active and is_button_touched(x, y, 20, 100, screen_width - 40, 50):
        if wearable.is_ar_supported():
            set ar_session to wearable.start_ar_session()
            set ar_active to true
            wearable.enable_gesture(wearable.GESTURE_TAP, true)
    else:
        if ar_active and is_button_touched(x, y, 20, screen_height - 60, screen_width - 40, 40):
            wearable.calibrate_ar()

# Navigation functions
define function navigate_screen that takes direction as String:
    create screens as List
    set screens to ["home", "health", "notifications", "ar"]

    create current_index as Integer
    set current_index to 0

    for i from 0 to screens.length - 1:
        if screens[i] is equal to current_screen:
            set current_index to i
            break

    if direction is equal to "next":
        set current_index to (current_index + 1) % screens.length
    else:
        set current_index to (current_index - 1 + screens.length) % screens.length

    set current_screen to screens[current_index]

define function scroll_up:
    # Implement scrolling for current screen
    pass

define function scroll_down:
    # Implement scrolling for current screen
    pass

define function handle_tap_gesture:
    # Handle double tap or special gestures
    if current_screen is equal to "ar" and ar_active:
        # Add virtual object at current gaze position
        create virtual_object as Object
        set virtual_object["text"] to "Hello AR!"
        set virtual_object["x"] to screen_width / 2
        set virtual_object["y"] to screen_height / 2
        ar_content.append(virtual_object)

# Wearable sensor management
define function initialize_wearable_sensors:
    # Start basic health monitoring
    if wearable.has_heart_rate_monitor():
        set heart_rate_session to wearable.start_heart_rate_monitoring()

    if wearable.has_step_counter():
        set step_session to wearable.start_step_counting()

    # Enable gesture recognition if supported
    if wearable.is_gesture_supported():
        wearable.enable_gesture(wearable.GESTURE_SWIPE_LEFT, true)
        wearable.enable_gesture(wearable.GESTURE_SWIPE_RIGHT, true)
        wearable.enable_gesture(wearable.GESTURE_TAP, true)

define function update_health_data:
    if heart_rate_session > 0:
        set current_heart_rate to wearable.get_current_heart_rate()

    set daily_steps to wearable.get_daily_steps()
    set calories_burned to wearable.get_calories_burned()

define function update_notifications:
    # Simulate receiving notifications
    create random_value as Integer
    set random_value to math.random(0, 100)

    if random_value < 5:  # 5% chance per update
        set notification_count to notification_count + 1
        wearable.vibrate_pattern([100, 200, 100])  # Vibration pattern

define function cleanup_wearable_sensors:
    if heart_rate_session > 0:
        wearable.stop_heart_rate_monitoring(heart_rate_session)

    if step_session > 0:
        wearable.stop_step_counting(step_session)

    if ar_session > 0:
        wearable.stop_ar_session(ar_session)

# Utility functions
define function is_button_touched that takes x as Integer, y as Integer, button_x as Integer, button_y as Integer, button_width as Integer, button_height as Integer and returns Boolean:
    if x >= button_x and x <= button_x + button_width and y >= button_y and y <= button_y + button_height:
        return true
    else:
        return false

define function is_button_touched_circular that takes touch_x as Integer, touch_y as Integer, center_x as Integer, center_y as Integer, radius as Integer and returns Boolean:
    create distance as Float
    set distance to math.sqrt((touch_x - center_x) * (touch_x - center_x) + (touch_y - center_y) * (touch_y - center_y))
    return distance <= radius

define function is_button_pressed that takes button_x as Integer, button_y as Integer, button_width as Integer, button_height as Integer and returns Boolean:
    create touch_coords as List
    set touch_coords to wearable.get_touch_coordinates()

    if touch_coords:
        create x as Integer
        set x to touch_coords[0]
        create y as Integer
        set y to touch_coords[1]

        return is_button_touched(x, y, button_x, button_y, button_width, button_height)
    else:
        return false

define function is_point_in_circle that takes px as Integer, py as Integer, cx as Integer, cy as Integer, radius as Integer and returns Boolean:
    create distance as Float
    set distance to math.sqrt((px - cx) * (px - cx) + (py - cy) * (py - cy))
    return distance <= radius

# Health data export
define function export_health_data:
    create health_report as Object
    set health_report["heart_rate"] to current_heart_rate
    set health_report["daily_steps"] to daily_steps
    set health_report["calories_burned"] to calories_burned
    set health_report["date"] to date.get_current_date()

    io.print("Health Report:")
    io.print("  Date: " + health_report["date"])
    io.print("  Heart Rate: " + string.format(health_report["heart_rate"]) + " BPM")
    io.print("  Daily Steps: " + string.format(health_report["daily_steps"]))
    io.print("  Calories Burned: " + string.format(health_report["calories_burned"]) + " kcal")

# AR content management
define function clear_ar_content:
    ar_content.clear()

define function add_ar_content that takes text as String, x as Float, y as Float:
    create content as Object
    set content["text"] to text
    set content["x"] to x
    set content["y"] to y
    ar_content.append(content)