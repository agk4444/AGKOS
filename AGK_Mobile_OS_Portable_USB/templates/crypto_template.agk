# AGK Cryptography Template - Encryption, Hashing & Security Operations
# This template demonstrates comprehensive cryptographic operations including
# hashing, encryption, digital signatures, key management, and secure random generation
# Perfect for: Security applications, authentication systems, data protection, secure communication

import crypto
import io
import logging
import json

# Global configuration
define constant TEST_MESSAGE as String = "This is a secret message for encryption testing."
define constant TEST_PASSWORD as String = "MySecurePassword123!"
define constant KEY_SIZE as Integer = 32

# Main application entry point
define function main:
    # Initialize logging for the crypto application
    create logger as Logger
    set logger to logging.get_logger("Crypto_App")
    logging.set_level(logger, logging.INFO)
    logging.add_console_handler(logger)

    logging.info(logger, "Starting AGK Cryptography Application")

    # Run the main application loop
    run_crypto_application_loop(logger)

# Main application loop with menu-driven interface
define function run_crypto_application_loop that takes logger as Logger:
    create running as Boolean
    set running to true

    while running:
        io.println("\nüîê AGK Cryptography Environment")
        io.println("1. Hashing Functions")
        io.println("2. Password Security")
        io.println("3. Symmetric Encryption (AES)")
        io.println("4. Asymmetric Encryption (RSA)")
        io.println("5. Digital Signatures")
        io.println("6. Random Number Generation")
        io.println("7. Key Derivation")
        io.println("8. HMAC Operations")
        io.println("9. Encoding/Decoding")
        io.println("10. Certificate Operations")
        io.println("11. Cryptographic Utilities")
        io.println("12. Exit")
        io.print("Enter your choice (1-12): ")

        create choice as String
        set choice to io.read_line()

        if choice == "1":
            hashing_demo(logger)
        else if choice == "2":
            password_demo(logger)
        else if choice == "3":
            aes_demo(logger)
        else if choice == "4":
            rsa_demo(logger)
        else if choice == "5":
            signature_demo(logger)
        else if choice == "6":
            random_demo(logger)
        else if choice == "7":
            key_derivation_demo(logger)
        else if choice == "8":
            hmac_demo(logger)
        else if choice == "9":
            encoding_demo(logger)
        else if choice == "10":
            certificate_demo(logger)
        else if choice == "11":
            utilities_demo(logger)
        else if choice == "12":
            set running to false
            logging.info(logger, "Crypto application shutting down")
        else:
            io.println("‚ùå Invalid choice. Please try again.")

# Hashing functions demonstration
define function hashing_demo that takes logger as Logger:
    io.println("\nüî¢ Hashing Functions")

    io.print("Enter text to hash: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to TEST_MESSAGE

    io.println("Text: '" + text + "'")
    io.println("‚îÄ" * 50)

    # Various hashing algorithms
    create sha256_hash as String
    set sha256_hash to crypto.sha256_hash(text)
    io.println("SHA256: " + sha256_hash)

    create md5_hash as String
    set md5_hash to crypto.md5_hash(text)
    io.println("MD5:    " + md5_hash)

    create sha1_hash as String
    set sha1_hash to crypto.sha1_hash(text)
    io.println("SHA1:   " + sha1_hash)

    # Hash properties demonstration
    io.println("\nHash Properties:")
    io.println("‚îÄ" * 30)
    io.println("SHA256 length: " + string(length(sha256_hash)) + " characters")
    io.println("MD5 length:    " + string(length(md5_hash)) + " characters")
    io.println("SHA1 length:   " + string(length(sha1_hash)) + " characters")

    # Hash consistency check
    create text2 as String
    set text2 to text + "x"
    create sha256_hash2 as String
    set sha256_hash2 to crypto.sha256_hash(text2)

    io.println("\nConsistency Check:")
    io.println("‚îÄ" * 30)
    io.println("Original:  " + sha256_hash)
    io.println("Modified:  " + sha256_hash2)
    io.println("Different: " + (sha256_hash != sha256_hash2 ? "Yes" : "No"))

    logging.info(logger, "Hashing operations completed")

# Password security demonstration
define function password_demo that takes logger as Logger:
    io.println("\nüîë Password Security")

    io.print("Enter password to hash: ")
    create password as String
    set password to io.read_line()

    if password == "":
        set password to TEST_PASSWORD

    io.println("Password: '" + password + "'")
    io.println("‚îÄ" * 50)

    # Password hashing with bcrypt
    create hashed_password as String
    set hashed_password to crypto.bcrypt_hash(password)
    io.println("Hashed: " + hashed_password)

    # Password verification
    create is_valid as Boolean
    set is_valid to crypto.verify_bcrypt(password, hashed_password)
    io.println("Verification: " + (is_valid ? "‚úÖ PASSED" : "‚ùå FAILED"))

    # Test with wrong password
    create wrong_password as String
    set wrong_password to password + "x"
    create is_valid_wrong as Boolean
    set is_valid_wrong to crypto.verify_bcrypt(wrong_password, hashed_password)
    io.println("Wrong password test: " + (not is_valid_wrong ? "‚úÖ PASSED" : "‚ùå FAILED"))

    io.println("\nPassword Strength Analysis:")
    io.println("‚îÄ" * 40)
    create strength as String
    set strength to analyze_password_strength(password)
    io.println("Strength: " + strength)

    logging.info(logger, "Password security operations completed")

# AES encryption demonstration
define function aes_demo that takes logger as Logger:
    io.println("\nüîí AES Encryption/Decryption")

    io.print("Enter message to encrypt: ")
    create message as String
    set message to io.read_line()

    if message == "":
        set message to TEST_MESSAGE

    io.print("Enter encryption key: ")
    create key as String
    set key to io.read_line()

    if key == "":
        set key to crypto.generate_aes_key()

    io.println("Message: '" + message + "'")
    io.println("Key: '" + key + "'")
    io.println("‚îÄ" * 50)

    # Encryption
    create encrypted as String
    set encrypted to crypto.aes_encrypt(message, key)
    io.println("Encrypted: " + encrypted)

    # Decryption
    create decrypted as String
    set decrypted to crypto.aes_decrypt(encrypted, key)
    io.println("Decrypted: '" + decrypted + "'")

    # Verification
    create success as Boolean
    set success to (message == decrypted)
    io.println("Verification: " + (success ? "‚úÖ PASSED" : "‚ùå FAILED"))

    # Test with wrong key
    create wrong_key as String
    set wrong_key to key + "x"
    create wrong_decrypt as String
    set wrong_decrypt to crypto.aes_decrypt(encrypted, wrong_key)
    io.println("Wrong key test: '" + wrong_decrypt + "'")

    logging.info(logger, "AES encryption operations completed")

# RSA encryption demonstration
define function rsa_demo that takes logger as Logger:
    io.println("\nüîê RSA Encryption/Decryption")

    io.print("Enter message to encrypt: ")
    create message as String
    set message to io.read_line()

    if message == "":
        set message to "RSA encryption test message"

    io.println("Message: '" + message + "'")
    io.println("‚îÄ" * 50)

    # Generate RSA keypair
    create keypair as Object
    set keypair to crypto.generate_rsa_keypair()
    io.println("Generated RSA keypair")

    # Extract keys (placeholder structure)
    create public_key as String
    set public_key to "public_key_from_keypair"
    create private_key as String
    set private_key to "private_key_from_keypair"

    # Encrypt with public key
    create encrypted as String
    set encrypted to crypto.rsa_encrypt(message, public_key)
    io.println("Encrypted: " + encrypted)

    # Decrypt with private key
    create decrypted as String
    set decrypted to crypto.rsa_decrypt(encrypted, private_key)
    io.println("Decrypted: '" + decrypted + "'")

    # Verification
    create success as Boolean
    set success to (message == decrypted)
    io.println("Verification: " + (success ? "‚úÖ PASSED" : "‚ùå FAILED"))

    logging.info(logger, "RSA encryption operations completed")

# Digital signatures demonstration
define function signature_demo that takes logger as Logger:
    io.println("\n‚úçÔ∏è Digital Signatures")

    io.print("Enter message to sign: ")
    create message as String
    set message to io.read_line()

    if message == "":
        set message to TEST_MESSAGE

    io.println("Message: '" + message + "'")
    io.println("‚îÄ" * 50)

    # Generate keypair for signing
    create keypair as Object
    set keypair to crypto.generate_rsa_keypair()

    create public_key as String
    set public_key to "public_key_from_keypair"
    create private_key as String
    set private_key to "private_key_from_keypair"

    # Create digital signature
    create signature as String
    set signature to crypto.sign_data(message, private_key)
    io.println("Signature: " + signature)

    # Verify signature
    create is_valid as Boolean
    set is_valid to crypto.verify_signature(message, signature, public_key)
    io.println("Signature valid: " + (is_valid ? "‚úÖ YES" : "‚ùå NO"))

    # Test with modified message
    create modified_message as String
    set modified_message to message + "x"
    create is_valid_modified as Boolean
    set is_valid_modified to crypto.verify_signature(modified_message, signature, public_key)
    io.println("Modified message test: " + (not is_valid_modified ? "‚úÖ PASSED" : "‚ùå FAILED"))

    logging.info(logger, "Digital signature operations completed")

# Random number generation demonstration
define function random_demo that takes logger as Logger:
    io.println("\nüé≤ Random Number Generation")

    io.print("Enter number of random bytes to generate: ")
    create byte_count_str as String
    set byte_count_str to io.read_line()

    create byte_count as Integer
    set byte_count to 16  # default
    if byte_count_str != "":
        set byte_count to int(byte_count_str)

    io.println("Generating " + string(byte_count) + " random bytes:")
    io.println("‚îÄ" * 50)

    # Generate random bytes
    create random_bytes as String
    set random_bytes to crypto.generate_random_bytes(byte_count)
    io.println("Random bytes: " + random_bytes)

    # Generate secure token
    io.print("Enter token length: ")
    create token_length_str as String
    set token_length_str to io.read_line()

    create token_length as Integer
    set token_length to 32  # default
    if token_length_str != "":
        set token_length to int(token_length_str)

    create secure_token as String
    set secure_token to crypto.generate_secure_token(token_length)
    io.println("Secure token: " + secure_token)

    # Demonstrate randomness properties
    io.println("\nRandomness Tests:")
    io.println("‚îÄ" * 30)

    create test_bytes1 as String
    set test_bytes1 to crypto.generate_random_bytes(10)
    create test_bytes2 as String
    set test_bytes2 to crypto.generate_random_bytes(10)

    io.println("Sequence 1: " + test_bytes1)
    io.println("Sequence 2: " + test_bytes2)
    io.println("Different: " + (test_bytes1 != test_bytes2 ? "‚úÖ YES" : "‚ùå NO"))

    logging.info(logger, "Random generation operations completed")

# Key derivation demonstration
define function key_derivation_demo that takes logger as Logger:
    io.println("\nüîë Key Derivation")

    io.print("Enter password: ")
    create password as String
    set password to io.read_line()

    if password == "":
        set password to TEST_PASSWORD

    io.println("Password: '" + password + "'")
    io.println("‚îÄ" * 50)

    # Generate salt
    create salt as String
    set salt to crypto.generate_salt()
    io.println("Generated salt: " + salt)

    # Derive key from password
    create derived_key as String
    set derived_key to crypto.derive_key(password, salt)
    io.println("Derived key: " + derived_key)

    # Test with same password and salt
    create derived_key2 as String
    set derived_key2 to crypto.derive_key(password, salt)
    io.println("Re-derived key: " + derived_key2)
    io.println("Keys match: " + (derived_key == derived_key2 ? "‚úÖ YES" : "‚ùå NO"))

    # Test with different salt
    create salt2 as String
    set salt2 to crypto.generate_salt()
    create derived_key3 as String
    set derived_key3 to crypto.derive_key(password, salt2)
    io.println("Different salt key: " + derived_key3)
    io.println("Keys match: " + (derived_key == derived_key3 ? "‚úÖ YES" : "‚ùå NO"))

    logging.info(logger, "Key derivation operations completed")

# HMAC operations demonstration
define function hmac_demo that takes logger as Logger:
    io.println("\nüîó HMAC Operations")

    io.print("Enter message for HMAC: ")
    create message as String
    set message to io.read_line()

    if message == "":
        set message to TEST_MESSAGE

    io.print("Enter key for HMAC: ")
    create key as String
    set key to io.read_line()

    if key == "":
        set key to "my_hmac_key"

    io.println("Message: '" + message + "'")
    io.println("Key: '" + key + "'")
    io.println("‚îÄ" * 50)

    # Generate HMAC
    create hmac_value as String
    set hmac_value to crypto.hmac_sha256(message, key)
    io.println("HMAC-SHA256: " + hmac_value)

    # Verify HMAC
    create is_valid as Boolean
    set is_valid to crypto.verify_hmac(message, hmac_value, key)
    io.println("HMAC verification: " + (is_valid ? "‚úÖ PASSED" : "‚ùå FAILED"))

    # Test with modified message
    create modified_message as String
    set modified_message to message + "x"
    create is_valid_modified as Boolean
    set is_valid_modified to crypto.verify_hmac(modified_message, hmac_value, key)
    io.println("Modified message test: " + (not is_valid_modified ? "‚úÖ PASSED" : "‚ùå FAILED"))

    # Test with wrong key
    create wrong_key as String
    set wrong_key to key + "x"
    create is_valid_wrong_key as Boolean
    set is_valid_wrong_key to crypto.verify_hmac(message, hmac_value, wrong_key)
    io.println("Wrong key test: " + (not is_valid_wrong_key ? "‚úÖ PASSED" : "‚ùå FAILED"))

    logging.info(logger, "HMAC operations completed")

# Encoding/decoding demonstration
define function encoding_demo that takes logger as Logger:
    io.println("\nüîÑ Encoding/Decoding")

    io.print("Enter text to encode: ")
    create text as String
    set text to io.read_line()

    if text == "":
        set text to "Hello, ‰∏ñÁïå! Special chars: @#$%^&*()"

    io.println("Original: '" + text + "'")
    io.println("‚îÄ" * 50)

    # Base64 encoding
    create b64_encoded as String
    set b64_encoded to crypto.base64_encode(text)
    io.println("Base64 encoded: " + b64_encoded)

    create b64_decoded as String
    set b64_decoded to crypto.base64_decode(b64_encoded)
    io.println("Base64 decoded: '" + b64_decoded + "'")

    # Hex encoding
    create hex_encoded as String
    set hex_encoded to crypto.hex_encode(text)
    io.println("Hex encoded: " + hex_encoded)

    create hex_decoded as String
    set hex_decoded to crypto.hex_decode(hex_encoded)
    io.println("Hex decoded: '" + hex_decoded + "'")

    # Verification
    create b64_success as Boolean
    set b64_success to (text == b64_decoded)
    io.println("Base64 verification: " + (b64_success ? "‚úÖ PASSED" : "‚ùå FAILED"))

    create hex_success as Boolean
    set hex_success to (text == hex_decoded)
    io.println("Hex verification: " + (hex_success ? "‚úÖ PASSED" : "‚ùå FAILED"))

    logging.info(logger, "Encoding/decoding operations completed")

# Certificate operations demonstration
define function certificate_demo that takes logger as Logger:
    io.println("\nüìú Certificate Operations")

    io.print("Enter certificate path (or press Enter for demo): ")
    create cert_path as String
    set cert_path to io.read_line()

    if cert_path == "":
        set cert_path to "/path/to/demo/certificate.pem"
        io.println("Using demo certificate path: " + cert_path)

    io.println("‚îÄ" * 50)

    # Load certificate (demo)
    create certificate as String
    set certificate to crypto.load_certificate(cert_path)
    io.println("Loaded certificate: " + certificate)

    # Certificate validation demo
    create ca_cert as String
    set ca_cert to crypto.load_certificate("/path/to/ca/certificate.pem")
    io.println("Loaded CA certificate: " + ca_cert)

    create is_valid as Boolean
    set is_valid to crypto.verify_certificate(certificate, ca_cert)
    io.println("Certificate validation: " + (is_valid ? "‚úÖ VALID" : "‚ùå INVALID"))

    # Certificate properties
    io.println("\nCertificate Information:")
    io.println("‚îÄ" * 30)
    io.println("Type: X.509 Certificate")
    io.println("Algorithm: RSA/SHA256")
    io.println("Valid from: 2024-01-01")
    io.println("Valid until: 2025-01-01")
    io.println("Issuer: Demo Certificate Authority")
    io.println("Subject: example.com")

    logging.info(logger, "Certificate operations completed")

# Cryptographic utilities demonstration
define function utilities_demo that takes logger as Logger:
    io.println("\nüõ†Ô∏è Cryptographic Utilities")

    io.println("1. Password strength checker")
    io.println("2. Key format validation")
    io.println("3. Hash comparison")
    io.println("4. Entropy calculation")
    io.print("Choose utility (1-4): ")

    create choice as String
    set choice to io.read_line()

    if choice == "1":
        create test_passwords as List
        set test_passwords to ["weak", "Stronger123", "VeryStrong123!", "P@ssw0rd!", "123456"]

        io.println("Password Strength Analysis:")
        io.println("‚îÄ" * 40)
        create i as Integer
        set i to 0
        while i < length(test_passwords):
            create pwd as String
            set pwd to test_passwords[i]
            create strength as String
            set strength to analyze_password_strength(pwd)
            io.println("  '" + pwd + "': " + strength)
            set i to i + 1

    else if choice == "2":
        create test_keys as List
        set test_keys to ["valid_key_123", "weak", "another_valid_key_456", "x"]

        io.println("Key Format Validation:")
        io.println("‚îÄ" * 30)
        create i as Integer
        set i to 0
        while i < length(test_keys):
            create key as String
            set key to test_keys[i]
            create is_valid as Boolean
            set is_valid to validate_key_format(key)
            io.println("  '" + key + "': " + (is_valid ? "Valid" : "Invalid"))
            set i to i + 1

    else if choice == "3":
        create hash1 as String
        set hash1 to crypto.sha256_hash("test data 1")
        create hash2 as String
        set hash2 to crypto.sha256_hash("test data 1")
        create hash3 as String
        set hash3 to crypto.sha256_hash("test data 2")

        io.println("Hash Comparison:")
        io.println("‚îÄ" * 30)
        io.println("Hash 1: " + hash1)
        io.println("Hash 2: " + hash2)
        io.println("Hash 3: " + hash3)
        io.println("Hash 1 = Hash 2: " + (hash1 == hash2 ? "‚úÖ Equal" : "‚ùå Different"))
        io.println("Hash 1 = Hash 3: " + (hash1 == hash3 ? "‚úÖ Equal" : "‚ùå Different"))

    else if choice == "4":
        create test_data as List
        set test_data to ["password", "P@ssw0rd123!", "randomstring", "AAAAAAAAAA"]

        io.println("Entropy Calculation:")
        io.println("‚îÄ" * 30)
        create i as Integer
        set i to 0
        while i < length(test_data):
            create data as String
            set data to test_data[i]
            create entropy as Float
            set entropy to calculate_entropy(data)
            io.println("  '" + data + "': " + string(entropy) + " bits")
            set i to i + 1

    logging.info(logger, "Cryptographic utilities completed")

# Helper functions
define function analyze_password_strength that takes password as String and returns String:
    if length(password) < 6:
        return "Very Weak"

    create has_lower as Boolean
    set has_lower to false
    create has_upper as Boolean
    set has_upper to false
    create has_digit as Boolean
    set has_digit to false
    create has_special as Boolean
    set has_special to false

    create i as Integer
    set i to 0
    while i < length(password):
        create char as String
        set char to substring(password, i, 1)
        if char >= "a" and char <= "z":
            set has_lower to true
        else if char >= "A" and char <= "Z":
            set has_upper to true
        else if char >= "0" and char <= "9":
            set has_digit to true
        else:
            set has_special to true
        set i to i + 1

    create score as Integer
    set score to 0
    if length(password) >= 8:
        set score to score + 1
    if has_lower:
        set score to score + 1
    if has_upper:
        set score to score + 1
    if has_digit:
        set score to score + 1
    if has_special:
        set score to score + 1

    if score >= 5:
        return "Very Strong"
    else if score >= 4:
        return "Strong"
    else if score >= 3:
        return "Medium"
    else if score >= 2:
        return "Weak"
    else:
        return "Very Weak"

define function validate_key_format that takes key as String and returns Boolean:
    if length(key) < 8:
        return false

    create has_alphanum as Boolean
    set has_alphanum to false
    create i as Integer
    set i to 0
    while i < length(key):
        create char as String
        set char to substring(key, i, 1)
        if (char >= "a" and char <= "z") or (char >= "A" and char <= "Z") or (char >= "0" and char <= "9"):
            set has_alphanum to true
        set i to i + 1

    return has_alphanum

define function calculate_entropy that takes data as String and returns Float:
    if length(data) == 0:
        return 0.0

    # Simple entropy calculation based on character frequency
    create char_counts as Object
    set char_counts to {}

    create i as Integer
    set i to 0
    while i < length(data):
        create char as String
        set char to substring(data, i, 1)
        if char_counts[char] is not defined:
            set char_counts[char] to 0
        set char_counts[char] to char_counts[char] + 1
        set i to i + 1

    create entropy as Float
    set entropy to 0.0
    create data_length as Integer
    set data_length to length(data)

    # This would need proper object iteration implementation
    # For demo purposes, return a placeholder
    return 42.5

define function substring that takes text as String, start as Integer, length as Integer and returns String:
    # Placeholder implementation
    return "substring_placeholder"

# Initialize the application
main()