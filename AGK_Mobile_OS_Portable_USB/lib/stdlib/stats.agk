# AGK Statistics Library
# Comprehensive statistical analysis and data processing functions
# Provides tools for data analysis, probability, and statistical computing

# Descriptive Statistics
define function mean that takes data as List and returns Float:
    # Calculate arithmetic mean (average)
    if list.length(data) = 0:
        return 0.0

    create sum as Float
    set sum to 0.0

    create i as Integer
    set i to 0
    while i < list.length(data):
        set sum to sum + data[i]
        set i to i + 1

    return sum / list.length(data)

define function median that takes data as List and returns Float:
    # Calculate median value
    if list.length(data) = 0:
        return 0.0

    # Sort data (simple bubble sort for demo)
    create sorted_data as List
    # Copy and sort data
    create i as Integer
    set i to 0
    while i < list.length(data):
        add data[i] to sorted_data
        set i to i + 1

    # Sort the copy
    set sorted_data to sort_numbers(sorted_data)

    create middle as Integer
    set middle to list.length(sorted_data) / 2

    if list.length(sorted_data) % 2 = 0:
        # Even number of elements
        create mid1 as Float
        set mid1 to sorted_data[middle - 1]
        create mid2 as Float
        set mid2 to sorted_data[middle]
        return (mid1 + mid2) / 2.0
    else:
        # Odd number of elements
        return sorted_data[middle]

define function mode that takes data as List and returns List:
    # Find mode(s) - most frequently occurring value(s)
    create frequency as Object

    create i as Integer
    set i to 0
    while i < list.length(data):
        create value as String
        set value to string.format(data[i])

        if object.has_key(frequency, value):
            create count as Integer
            set count to frequency[value]
            set frequency[value] to count + 1
        else:
            set frequency[value] to 1

        set i to i + 1

    # Find maximum frequency
    create max_freq as Integer
    set max_freq to 0

    create keys as List
    set keys to object.keys(frequency)

    create j as Integer
    set j to 0
    while j < list.length(keys):
        create key as String
        set key to keys[j]
        create freq as Integer
        set freq to frequency[key]

        if freq > max_freq:
            set max_freq to freq

        set j to j + 1

    # Collect all values with maximum frequency
    create modes as List
    set j to 0
    while j < list.length(keys):
        create key as String
        set key to keys[j]
        create freq as Integer
        set freq to frequency[key]

        if freq = max_freq:
            add string.to_number(key) to modes

        set j to j + 1

    return modes

define function variance that takes data as List and returns Float:
    # Calculate population variance
    if list.length(data) <= 1:
        return 0.0

    create mean_value as Float
    set mean_value to mean(data)

    create sum_squares as Float
    set sum_squares to 0.0

    create i as Integer
    set i to 0
    while i < list.length(data):
        create diff as Float
        set diff to data[i] - mean_value
        set sum_squares to sum_squares + (diff * diff)
        set i to i + 1

    return sum_squares / list.length(data)

define function standard_deviation that takes data as List and returns Float:
    # Calculate population standard deviation
    create var as Float
    set var to variance(data)

    if var = 0.0:
        return 0.0

    # Simple square root approximation (for demo)
    return sqrt_approx(var)

define function sample_variance that takes data as List and returns Float:
    # Calculate sample variance (n-1 denominator)
    if list.length(data) <= 1:
        return 0.0

    create mean_value as Float
    set mean_value to mean(data)

    create sum_squares as Float
    set sum_squares to 0.0

    create i as Integer
    set i to 0
    while i < list.length(data):
        create diff as Float
        set diff to data[i] - mean_value
        set sum_squares to sum_squares + (diff * diff)
        set i to i + 1

    return sum_squares / (list.length(data) - 1)

define function sample_standard_deviation that takes data as List and returns Float:
    # Calculate sample standard deviation
    create var as Float
    set var to sample_variance(data)

    if var = 0.0:
        return 0.0

    return sqrt_approx(var)

# Data Range and Distribution
define function minimum that takes data as List and returns Float:
    # Find minimum value
    if list.length(data) = 0:
        return 0.0

    create min_val as Float
    set min_val to data[0]

    create i as Integer
    set i to 1
    while i < list.length(data):
        if data[i] < min_val:
            set min_val to data[i]
        set i to i + 1

    return min_val

define function maximum that takes data as List and returns Float:
    # Find maximum value
    if list.length(data) = 0:
        return 0.0

    create max_val as Float
    set max_val to data[0]

    create i as Integer
    set i to 1
    while i < list.length(data):
        if data[i] > max_val:
            set max_val to data[i]
        set i to i + 1

    return max_val

define function range that takes data as List and returns Float:
    # Calculate range (max - min)
    create min_val as Float
    set min_val to minimum(data)

    create max_val as Float
    set max_val to maximum(data)

    return max_val - min_val

define function quartiles that takes data as List and returns Object:
    # Calculate quartiles (Q1, Q2/median, Q3)
    create result as Object

    if list.length(data) = 0:
        set result["q1"] to 0.0
        set result["q2"] to 0.0
        set result["q3"] to 0.0
        return result
    else if list.length(data) = 1:
        set result["q1"] to data[0]
        set result["q2"] to data[0]
        set result["q3"] to data[0]
        return result

    # Sort data
    create sorted_data as List
    create i as Integer
    set i to 0
    while i < list.length(data):
        add data[i] to sorted_data
        set i to i + 1

    set sorted_data to sort_numbers(sorted_data)

    create n as Integer
    set n to list.length(sorted_data)

    # Calculate quartiles
    create q1_pos as Float
    set q1_pos to n * 0.25
    create q1_index as Integer
    set q1_index to q1_pos
    set result["q1"] to sorted_data[q1_index]

    create q2_pos as Float
    set q2_pos to n * 0.5
    create q2_index as Integer
    set q2_index to q2_pos
    set result["q2"] to sorted_data[q2_index]

    create q3_pos as Float
    set q3_pos to n * 0.75
    create q3_index as Integer
    set q3_index to q3_pos
    set result["q3"] to sorted_data[q3_index]

    return result

define function percentile that takes data as List, p as Float and returns Float:
    # Calculate percentile (p between 0 and 100)
    if list.length(data) = 0 or p < 0 or p > 100:
        return 0.0

    # Sort data
    create sorted_data as List
    create i as Integer
    set i to 0
    while i < list.length(data):
        add data[i] to sorted_data
        set i to i + 1

    set sorted_data to sort_numbers(sorted_data)

    create pos as Float
    set pos to (p / 100.0) * (list.length(sorted_data) - 1)

    create index as Integer
    set index to pos

    if index = list.length(sorted_data) - 1:
        return sorted_data[index]
    else:
        create frac as Float
        set frac to pos - index
        return sorted_data[index] * (1 - frac) + sorted_data[index + 1] * frac

# Correlation and Covariance
define function covariance that takes x_data as List, y_data as List and returns Float:
    # Calculate covariance between two datasets
    if list.length(x_data) != list.length(y_data) or list.length(x_data) = 0:
        return 0.0

    create x_mean as Float
    set x_mean to mean(x_data)

    create y_mean as Float
    set y_mean to mean(y_data)

    create sum as Float
    set sum to 0.0

    create i as Integer
    set i to 0
    while i < list.length(x_data):
        create x_diff as Float
        set x_diff to x_data[i] - x_mean

        create y_diff as Float
        set y_diff to y_data[i] - y_mean

        set sum to sum + (x_diff * y_diff)
        set i to i + 1

    return sum / list.length(x_data)

define function correlation that takes x_data as List, y_data as List and returns Float:
    # Calculate Pearson correlation coefficient
    create cov as Float
    set cov to covariance(x_data, y_data)

    create x_std as Float
    set x_std to standard_deviation(x_data)

    create y_std as Float
    set y_std to standard_deviation(y_data)

    if x_std = 0.0 or y_std = 0.0:
        return 0.0

    return cov / (x_std * y_std)

# Linear Regression
define function linear_regression that takes x_data as List, y_data as List and returns Object:
    # Simple linear regression (y = mx + b)
    create result as Object

    if list.length(x_data) != list.length(y_data) or list.length(x_data) < 2:
        set result["slope"] to 0.0
        set result["intercept"] to 0.0
        set result["r_squared"] to 0.0
        return result

    create n as Integer
    set n to list.length(x_data)

    create x_mean as Float
    set x_mean to mean(x_data)

    create y_mean as Float
    set y_mean to mean(y_data)

    # Calculate slope (m)
    create numerator as Float
    set numerator to 0.0
    create denominator as Float
    set denominator to 0.0

    create i as Integer
    set i to 0
    while i < n:
        create x_diff as Float
        set x_diff to x_data[i] - x_mean

        create y_diff as Float
        set y_diff to y_data[i] - y_mean

        set numerator to numerator + (x_diff * y_diff)
        set denominator to denominator + (x_diff * x_diff)
        set i to i + 1

    create slope as Float
    if denominator != 0.0:
        set slope to numerator / denominator
    else:
        set slope to 0.0

    # Calculate intercept (b)
    create intercept as Float
    set intercept to y_mean - (slope * x_mean)

    # Calculate R-squared
    create y_predicted as List
    set i to 0
    while i < n:
        create pred as Float
        set pred to (slope * x_data[i]) + intercept
        add pred to y_predicted
        set i to i + 1

    create ss_res as Float
    set ss_res to 0.0
    create ss_tot as Float
    set ss_tot to 0.0

    set i to 0
    while i < n:
        create y_diff as Float
        set y_diff to y_data[i] - y_predicted[i]
        set ss_res to ss_res + (y_diff * y_diff)

        create total_diff as Float
        set total_diff to y_data[i] - y_mean
        set ss_tot to ss_tot + (total_diff * total_diff)
        set i to i + 1

    create r_squared as Float
    if ss_tot != 0.0:
        set r_squared to 1.0 - (ss_res / ss_tot)
    else:
        set r_squared to 0.0

    set result["slope"] to slope
    set result["intercept"] to intercept
    set result["r_squared"] to r_squared

    return result

define function predict that takes regression as Object, x_value as Float and returns Float:
    # Make prediction using linear regression model
    create slope as Float
    set slope to regression["slope"]

    create intercept as Float
    set intercept to regression["intercept"]

    return (slope * x_value) + intercept

# Data Sampling and Randomization
define function sample that takes data as List, sample_size as Integer and returns List:
    # Random sample from data
    create result as List

    if sample_size >= list.length(data):
        # Return copy of all data
        create i as Integer
        set i to 0
        while i < list.length(data):
            add data[i] to result
            set i to i + 1
        return result
    else if sample_size <= 0:
        return result

    # Simple random sampling without replacement
    create available_indices as List
    create i as Integer
    set i to 0
    while i < list.length(data):
        add i to available_indices
        set i to i + 1

    create samples_taken as Integer
    set samples_taken to 0

    while samples_taken < sample_size and list.length(available_indices) > 0:
        create random_index as Integer
        set random_index to math.random() * list.length(available_indices)

        create data_index as Integer
        set data_index to available_indices[random_index]

        add data[data_index] to result

        # Remove used index
        create new_indices as List
        create j as Integer
        set j to 0
        while j < list.length(available_indices):
            if j != random_index:
                add available_indices[j] to new_indices
            set j to j + 1

        set available_indices to new_indices
        set samples_taken to samples_taken + 1

    return result

define function shuffle that takes data as List and returns List:
    # Shuffle data randomly (Fisher-Yates algorithm)
    create result as List
    create i as Integer
    set i to 0
    while i < list.length(data):
        add data[i] to result
        set i to i + 1

    # Fisher-Yates shuffle
    create n as Integer
    set n to list.length(result)

    create j as Integer
    set j to n - 1
    while j > 0:
        create k as Integer
        set k to math.random() * (j + 1)

        # Swap
        create temp as Float
        set temp to result[j]
        set result[j] to result[k]
        set result[k] to temp

        set j to j - 1

    return result

# Utility Functions
define function sort_numbers that takes data as List and returns List:
    # Simple bubble sort for demonstration
    create result as List
    create i as Integer
    set i to 0
    while i < list.length(data):
        add data[i] to result
        set i to i + 1

    create n as Integer
    set n to list.length(result)

    create j as Integer
    set j to 0
    while j < n - 1:
        create k as Integer
        set k to 0
        while k < n - j - 1:
            if result[k] > result[k + 1]:
                create temp as Float
                set temp to result[k]
                set result[k] to result[k + 1]
                set result[k + 1] to temp
            set k to k + 1
        set j to j + 1

    return result

define function sqrt_approx that takes x as Float and returns Float:
    # Simple square root approximation using Newton's method
    if x = 0.0:
        return 0.0
    else if x < 0.0:
        return 0.0  # Return 0 for negative numbers

    create guess as Float
    set guess to x / 2.0

    create iterations as Integer
    set iterations to 0

    while iterations < 10:  # Limit iterations for demo
        create new_guess as Float
        set new_guess to (guess + x / guess) / 2.0

        if abs(new_guess - guess) < 0.0001:
            return new_guess

        set guess to new_guess
        set iterations to iterations + 1

    return guess

define function abs that takes x as Float and returns Float:
    # Absolute value function
    if x < 0.0:
        return -x
    else:
        return x

# Example usage patterns
define function descriptive_stats_example:
    # Example: Calculate comprehensive descriptive statistics
    create data as List
    add 12.0 to data
    add 15.0 to data
    add 18.0 to data
    add 22.0 to data
    add 25.0 to data
    add 30.0 to data

    io.print("Descriptive Statistics Example:")
    io.print("Data: " + format_list(data))

    create mean_val as Float
    set mean_val to mean(data)
    io.print("Mean: " + string.format(mean_val))

    create median_val as Float
    set median_val to median(data)
    io.print("Median: " + string.format(median_val))

    create modes as List
    set modes to mode(data)
    io.print("Mode: " + format_list(modes))

    create min_val as Float
    set min_val to minimum(data)
    io.print("Minimum: " + string.format(min_val))

    create max_val as Float
    set max_val to maximum(data)
    io.print("Maximum: " + string.format(max_val))

    create range_val as Float
    set range_val to range(data)
    io.print("Range: " + string.format(range_val))

    create std_dev as Float
    set std_dev to standard_deviation(data)
    io.print("Standard Deviation: " + string.format(std_dev))

    create quartiles_data as Object
    set quartiles_data to quartiles(data)
    io.print("Q1: " + string.format(quartiles_data["q1"]))
    io.print("Q2 (Median): " + string.format(quartiles_data["q2"]))
    io.print("Q3: " + string.format(quartiles_data["q3"]))

define function correlation_example:
    # Example: Analyze correlation between two datasets
    create x_data as List  # Study hours
    add 2.0 to x_data
    add 3.0 to x_data
    add 4.0 to x_data
    add 5.0 to x_data
    add 6.0 to x_data

    create y_data as List  # Test scores
    add 65.0 to y_data
    add 70.0 to y_data
    add 75.0 to y_data
    add 80.0 to y_data
    add 85.0 to y_data

    io.print("Correlation Example:")
    io.print("Study Hours: " + format_list(x_data))
    io.print("Test Scores: " + format_list(y_data))

    create corr as Float
    set corr to correlation(x_data, y_data)
    io.print("Correlation: " + string.format(corr))

    if corr > 0.8:
        io.print("Strong positive correlation")
    else if corr > 0.5:
        io.print("Moderate positive correlation")
    else if corr > -0.5:
        io.print("Weak correlation")
    else if corr > -0.8:
        io.print("Moderate negative correlation")
    else:
        io.print("Strong negative correlation")

define function regression_example:
    # Example: Linear regression analysis
    create x_data as List  # Independent variable
    add 1.0 to x_data
    add 2.0 to x_data
    add 3.0 to x_data
    add 4.0 to x_data
    add 5.0 to x_data

    create y_data as List  # Dependent variable
    add 2.0 to y_data
    add 4.0 to y_data
    add 6.0 to y_data
    add 8.0 to y_data
    add 10.0 to y_data

    io.print("Linear Regression Example:")
    io.print("X values: " + format_list(x_data))
    io.print("Y values: " + format_list(y_data))

    create regression as Object
    set regression to linear_regression(x_data, y_data)

    io.print("Slope (m): " + string.format(regression["slope"]))
    io.print("Intercept (b): " + string.format(regression["intercept"]))
    io.print("R-squared: " + string.format(regression["r_squared"]))
    io.print("Equation: y = " + string.format(regression["slope"]) + "x + " + string.format(regression["intercept"]))

    # Make predictions
    create prediction as Float
    set prediction to predict(regression, 6.0)
    io.print("Prediction for x=6: " + string.format(prediction))

define function sampling_example:
    # Example: Data sampling and randomization
    create population as List
    create i as Integer
    set i to 1
    while i <= 20:
        add i to population
        set i to i + 1

    io.print("Sampling Example:")
    io.print("Population: " + format_list(population))

    # Random sample
    create sample_data as List
    set sample_data to sample(population, 5)
    io.print("Random sample (n=5): " + format_list(sample_data))

    # Shuffle
    create shuffled as List
    set shuffled to shuffle(population)
    io.print("Shuffled: " + format_list(shuffled))

define function format_list that takes data as List and returns String:
    # Helper function to format list for display
    create result as String
    set result to "["

    create i as Integer
    set i to 0
    while i < list.length(data):
        if i > 0:
            set result to result + ", "

        set result to result + string.format(data[i])
        set i to i + 1

    set result to result + "]"
    return result