# AGK Database Library
# SQLite database integration for AGK applications
# Provides SQL database operations with a clean, safe interface

# Database connection management
define function connect that takes database_path as String and returns Database:
    # Create database connection
    # In implementation: return sqlite3.connect(database_path)
    create db as Database
    # Implementation would create actual SQLite connection
    return db

define function close that takes db as Database:
    # Close database connection
    # In implementation: db.close()
    pass

# Schema operations
define function create_table that takes db as Database, table_name as String, columns as List and returns Boolean:
    # Create table with given columns
    # columns format: ["id INTEGER PRIMARY KEY", "name TEXT", "email TEXT UNIQUE"]

    create sql as String
    set sql to "CREATE TABLE IF NOT EXISTS " + table_name + " ("

    create i as Integer
    set i to 0
    while i < columns length:
        if i > 0:
            set sql to sql + ", "
        set sql to sql + columns[i]
        set i to i + 1

    set sql to sql + ")"

    create result as QueryResult
    set result to execute(db, sql)

    if result["success"]:
        return true
    else:
        return false

define function drop_table that takes db as Database, table_name as String and returns Boolean:
    # Drop table if it exists
    create sql as String
    set sql to "DROP TABLE IF EXISTS " + table_name

    create result as QueryResult
    set result to execute(db, sql)

    if result["success"]:
        return true
    else:
        return false

define function table_exists that takes db as Database, table_name as String and returns Boolean:
    # Check if table exists
    create sql as String
    set sql to "SELECT name FROM sqlite_master WHERE type='table' AND name=?"

    create result as QueryResult
    set result to execute(db, sql, [table_name])

    if result["success"] and result["rows"] length > 0:
        return true
    else:
        return false

define function get_table_schema that takes db as Database, table_name as String and returns List:
    # Get table column information
    create sql as String
    set sql to "PRAGMA table_info(" + table_name + ")"

    create result as QueryResult
    set result to execute(db, sql)

    create schema as List
    if result["success"]:
        set schema to result["rows"]

    return schema

# CRUD Operations
define function insert that takes db as Database, table_name as String, data as Object and returns Integer:
    # Insert single record
    # data format: {"column1": "value1", "column2": "value2"}

    create columns as List
    create values as List
    create placeholders as List

    # Extract columns and values
    create keys as List
    set keys to object.keys(data)

    create i as Integer
    set i to 0
    while i < keys length:
        create key as String
        set key to keys[i]

        add key to columns
        add data[key] to values
        add "?" to placeholders

        set i to i + 1

    create sql as String
    set sql to "INSERT INTO " + table_name + " ("
    set sql to sql + string.join(columns, ", ") + ") VALUES ("
    set sql to sql + string.join(placeholders, ", ") + ")"

    create result as QueryResult
    set result to execute(db, sql, values)

    if result["success"]:
        return result["last_insert_id"]
    else:
        return -1

define function insert_many that takes db as Database, table_name as String, records as List and returns Integer:
    # Insert multiple records efficiently
    if records length = 0:
        return 0

    create first_record as Object
    set first_record to records[0]
    create columns as List
    set columns to object.keys(first_record)

    create sql as String
    set sql to "INSERT INTO " + table_name + " ("
    set sql to sql + string.join(columns, ", ") + ") VALUES "

    # Build placeholders for each record
    create all_values as List
    create i as Integer
    set i to 0
    while i < records length:
        if i > 0:
            set sql to sql + ", "

        create placeholders as List
        create j as Integer
        set j to 0
        while j < columns length:
            add "?" to placeholders
            create column as String
            set column to columns[j]
            add records[i][column] to all_values
            set j to j + 1

        set sql to sql + "(" + string.join(placeholders, ", ") + ")"
        set i to i + 1

    create result as QueryResult
    set result to execute(db, sql, all_values)

    if result["success"]:
        return result["rows_affected"]
    else:
        return -1

define function query that takes db as Database, sql as String and returns QueryResult:
    # Execute SELECT query
    create result as QueryResult
    set result to execute(db, sql)

    return result

define function query_with_params that takes db as Database, sql as String, params as List and returns QueryResult:
    # Execute SELECT query with parameters
    create result as QueryResult
    set result to execute(db, sql, params)

    return result

define function update that takes db as Database, table_name as String, data as Object, where_clause as String, where_params as List and returns Integer:
    # Update records
    # data format: {"column1": "new_value1", "column2": "new_value2"}

    create set_parts as List
    create values as List

    create keys as List
    set keys to object.keys(data)

    create i as Integer
    set i to 0
    while i < keys length:
        create key as String
        set key to keys[i]

        add key + " = ?" to set_parts
        add data[key] to values

        set i to i + 1

    create sql as String
    set sql to "UPDATE " + table_name + " SET "
    set sql to sql + string.join(set_parts, ", ")

    if where_clause is not empty:
        set sql to sql + " WHERE " + where_clause
        # Add where parameters to values
        create j as Integer
        set j to 0
        while j < where_params length:
            add where_params[j] to values
            set j to j + 1

    create result as QueryResult
    set result to execute(db, sql, values)

    if result["success"]:
        return result["rows_affected"]
    else:
        return -1

define function delete that takes db as Database, table_name as String, where_clause as String, where_params as List and returns Integer:
    # Delete records
    create sql as String
    set sql to "DELETE FROM " + table_name

    if where_clause is not empty:
        set sql to sql + " WHERE " + where_clause

    create result as QueryResult
    set result to execute(db, sql, where_params)

    if result["success"]:
        return result["rows_affected"]
    else:
        return -1

# Utility functions
define function get_last_insert_id that takes db as Database and returns Integer:
    # Get last inserted row ID
    create result as QueryResult
    set result to execute(db, "SELECT last_insert_rowid()")

    if result["success"] and result["rows"] length > 0:
        return result["rows"][0]["last_insert_rowid()"]
    else:
        return -1

define function get_row_count that takes db as Database, table_name as String and returns Integer:
    # Get total row count for table
    create sql as String
    set sql to "SELECT COUNT(*) as count FROM " + table_name

    create result as QueryResult
    set result to execute(db, sql)

    if result["success"] and result["rows"] length > 0:
        return result["rows"][0]["count"]
    else:
        return -1

define function escape_string that takes input as String and returns String:
    # Escape single quotes for SQL
    create escaped as String
    set escaped to string.replace(input, "'", "''")
    return escaped

# Transaction support
define function begin_transaction that takes db as Database and returns Boolean:
    # Begin database transaction
    create result as QueryResult
    set result to execute(db, "BEGIN TRANSACTION")

    return result["success"]

define function commit_transaction that takes db as Database and returns Boolean:
    # Commit database transaction
    create result as QueryResult
    set result to execute(db, "COMMIT")

    return result["success"]

define function rollback_transaction that takes db as Database and returns Boolean:
    # Rollback database transaction
    create result as QueryResult
    set result to execute(db, "ROLLBACK")

    return result["success"]

# Migration support
define function get_database_version that takes db as Database and returns Integer:
    # Get user version (for migrations)
    create result as QueryResult
    set result to execute(db, "PRAGMA user_version")

    if result["success"] and result["rows"] length > 0:
        return result["rows"][0]["user_version"]
    else:
        return -1

define function set_database_version that takes db as Database, version as Integer and returns Boolean:
    # Set user version
    create sql as String
    set sql to "PRAGMA user_version = " + string.format(version)

    create result as QueryResult
    set result to execute(db, sql)

    return result["success"]

# Core execution function (would be implemented in Python runtime)
define function execute that takes db as Database, sql as String, params as List and returns QueryResult:
    # Core SQL execution function
    # This would be implemented in the Python runtime with actual SQLite calls

    create result as QueryResult
    create result["success"] as Boolean
    create result["rows"] as List
    create result["row_count"] as Integer
    create result["last_insert_id"] as Integer
    create result["rows_affected"] as Integer
    create result["error_message"] as String

    # Implementation would execute SQL and populate result object
    # For demo purposes, we'll return a mock successful result
    set result["success"] to true
    set result["rows"] to []
    set result["row_count"] to 0
    set result["last_insert_id"] to 1
    set result["rows_affected"] to 1
    set result["error_message"] to ""

    return result

# Helper functions for working with results
define function get_rows that takes result as QueryResult and returns List:
    return result["rows"]

define function get_row_count that takes result as QueryResult and returns Integer:
    return result["row_count"]

define function get_single_value that takes result as QueryResult, column as String and returns String:
    if result["rows"] length > 0:
        create row as Object
        set row to result["rows"][0]
        return row[column]
    else:
        return ""

define function is_success that takes result as QueryResult and returns Boolean:
    return result["success"]

define function get_error_message that takes result as QueryResult and returns String:
    return result["error_message"]

# Example usage patterns
define function example_usage:
    # Connect to database
    create db as Database
    set db to connect("myapp.db")

    # Create users table
    create columns as List
    add "id INTEGER PRIMARY KEY AUTOINCREMENT" to columns
    add "username TEXT UNIQUE NOT NULL" to columns
    add "email TEXT UNIQUE NOT NULL" to columns
    add "created_at DATETIME DEFAULT CURRENT_TIMESTAMP" to columns

    create_table(db, "users", columns)

    # Insert a user
    create user_data as Object
    set user_data["username"] to "john_doe"
    set user_data["email"] to "john@example.com"

    create user_id as Integer
    set user_id to insert(db, "users", user_data)

    # Query users
    create user_query as QueryResult
    set user_query to query(db, "SELECT * FROM users WHERE username = 'john_doe'")

    if is_success(user_query):
        create users as List
        set users to get_rows(user_query)
        io.print("Found " + string.format(get_row_count(user_query)) + " users")
    else:
        io.print("Query failed: " + get_error_message(user_query))

    # Update user
    create update_data as Object
    set update_data["email"] to "john.doe@example.com"

    create rows_updated as Integer
    set rows_updated to update(db, "users", update_data, "id = ?", [user_id])

    # Delete user
    create rows_deleted as Integer
    set rows_deleted to delete(db, "users", "id = ?", [user_id])

    # Close connection
    close(db)